/**
 * Avatar Generation Service
 * Orchestrates the 3D realistic avatar generation process using measurements and preferences
 * Uses PhotoMaker for personalized avatar creation with user photos and measurements
 */

import { nanoBananaAvatarService, NanoBananaGenerationRequest, Avatar3DData } from './nanoBananaAvatarService';
import { photoMakerAvatarService, PersonalizedAvatar3DData } from './photoMakerAvatarService';
import { nanoBananaEditService, Enhanced3DAvatar } from './nanoBananaEditService';
import { geminiCGIService, CGI3DAvatar } from './geminiCGIService';
import { byteDanceSeedreamService, ByteDanceSeedreamResponse, CGIMeasurements } from './byteDanceSeedreamService';
import { photoUploadService } from './photoUploadService';
import { environmentConfig } from './environmentConfig';

// Force recompile to check for duplicate method warnings

export interface GenerationProgress {
  stage: string;
  progress: number; // 0-100
  message: string;
  estimatedTimeRemaining?: number;
}

export interface AvatarGenerationResult {
  success: boolean;
  avatarData?: {
    imageUrl?: string;          // Primary 3D realistic image URL
    description?: string;       // Generated description from Nano Banana
    enhancedImageUrl?: string;  // Enhanced/edited version (legacy)
    previewUrl?: string;        // Thumbnail/preview (legacy compatibility)
    modelUrl?: string;          // Legacy 3D model (deprecated)
    metadata?: {
      prompt?: string;
      style?: string;
      quality?: string;
      generation_time?: number;
      model?: string;
      perspective?: string;
      lighting?: string;
      // Legacy 2D CGI metadata (deprecated)
      seed?: number;
      vertices?: number;
      faces?: number;
      materials?: number;
      animations?: string[];
    };
    qualityScore?: number;
  };
  error?: string;
}

export class AvatarGenerationService {
  private currentGenerationId: string | null = null;
  private progressCallbacks: Set<(progress: GenerationProgress) => void> = new Set();

  /**
   * Start the avatar generation process
   */
  async generateAvatar(
    capturedPhotos: any[],
    measurements: any,
    onProgress?: (progress: GenerationProgress) => void
  ): Promise<AvatarGenerationResult> {
    try {
      // Add progress callback if provided
      if (onProgress) {
        this.progressCallbacks.add(onProgress);
      }

      // Step 1: Validate input data
      this.notifyProgress({
        stage: 'Validating photos and measurements',
        progress: 5,
        message: 'Checking input data quality...'
      });

      const validationResult = this.validateInputData(capturedPhotos, measurements);
      if (!validationResult.isValid) {
        throw new Error(`Validation failed: ${validationResult.errors.join(', ')}`);
      }

      // Step 2: Determine which avatar generation model to use
      const avatarConfig = environmentConfig.getAvatarGenerationConfig();
      const usePhotoMaker = environmentConfig.shouldUsePhotoMaker();
      const useNanoBananaEdit = environmentConfig.shouldUseNanoBananaEdit();
      const useGeminiCGI = environmentConfig.shouldUseGeminiCGI();
      const useByteDanceSeedream = environmentConfig.shouldUseByteDanceSeedream();
      const useProductionApi = environmentConfig.shouldUseProductionApi();

      if (!useProductionApi) {
        console.log('üîß Using development fallback mode (no real API calls)');
        if (useByteDanceSeedream) {
          const cgiConfig = environmentConfig.getCGIEnhancementConfig();
          return await this.generateFallbackByteDanceAvatar(capturedPhotos, measurements, cgiConfig.qualityPreset);
        } else if (useGeminiCGI) {
          const cgiConfig = environmentConfig.getCGIEnhancementConfig();
          return await this.generateFallback3DCGIAvatar(measurements, cgiConfig.qualityPreset);
        } else if (useNanoBananaEdit) {
          const cgiConfig = environmentConfig.getCGIEnhancementConfig();
          return await this.generateFallbackEnhancedAvatar(capturedPhotos, measurements, cgiConfig.qualityPreset);
        } else if (usePhotoMaker) {
          const cgiConfig = environmentConfig.getCGIEnhancementConfig();
          return await this.generateFallbackPersonalizedAvatar(capturedPhotos, measurements, cgiConfig.qualityPreset);
        } else {
          return await this.generateFallback3DAvatar(capturedPhotos, measurements);
        }
      }

      if (useByteDanceSeedream) {
        console.log('‚úÖ Using ByteDance Seedream for photo-to-CGI transformation');
        return await this.generateByteDanceAvatar(capturedPhotos, measurements);
      } else if (useGeminiCGI) {
        console.log('‚úÖ Using Gemini 2.5 Flash Image for 3D CGI generation');
        return await this.generateGeminiCGIAvatar(measurements, capturedPhotos);
      } else if (useNanoBananaEdit) {
        console.log('‚úÖ Using Nano Banana Edit for CGI photo enhancement');
        return await this.generateNanoBananaEditAvatar(capturedPhotos, measurements);
      } else if (usePhotoMaker) {
        console.log('‚úÖ Using PhotoMaker for personalized avatar generation');
        return await this.generatePhotoMakerAvatar(capturedPhotos, measurements);
      } else {
        console.log('‚úÖ Using Nano Banana for text-to-image generation');
        return await this.generateNanoBananaAvatar(capturedPhotos, measurements);
      }

      // Step 6: Final processing happens in the try block above
      // This section is now handled by the 3D realistic generation flow

      this.notifyProgress({
        stage: '3D realistic avatar generation complete',
        progress: 100,
        message: 'Your photorealistic 3D avatar is ready!'
      });

      // Clean up
      this.currentGenerationId = null;
      if (onProgress) {
        this.progressCallbacks.delete(onProgress);
      }

      // Note: result is returned from the try block above

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Avatar generation failed';

      this.notifyProgress({
        stage: 'Generation failed',
        progress: 0,
        message: errorMessage
      });

      // Clean up
      this.currentGenerationId = null;
      if (onProgress) {
        this.progressCallbacks.delete(onProgress);
      }

      return {
        success: false,
        error: errorMessage
      };
    }
  }

  /**
   * Cancel current avatar generation
   */
  async cancelGeneration(): Promise<void> {
    if (this.currentGenerationId) {
      // Note: Avaturn API might not support cancellation
      // This is a placeholder for future implementation
      this.currentGenerationId = null;
      this.progressCallbacks.clear();
    }
  }

  /**
   * Validate input data for 3D realistic generation (measurements-focused)
   */
  private validateInputData(photos: any[], measurements: any): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    const warnings: string[] = [];

    console.log('üîç Validating measurements for 3D realistic generation:', measurements);
    console.log('üîç Photos provided (optional for 3D generation):', photos?.length || 0);

    // Photos are optional for Nano Banana text-to-image generation
    if (photos && photos.length > 0) {
      console.log('üì∏ Photos provided but not required for 3D realistic generation');
      const availableViews = photos.map(p => p.view || p.type || 'unknown');
      console.log('üì∏ Available photo views (for reference):', availableViews);
    } else {
      console.log('üì∏ No photos provided - using pure text-to-image generation');
    }

    // Validate measurements (more lenient)
    if (!measurements) {
      // In development, create default measurements instead of failing
      console.log('‚ö†Ô∏è No measurements provided, using defaults for development');
      warnings.push('‚ö†Ô∏è Using default measurements. For better accuracy, please provide your measurements.');
    } else {
      const requiredMeasurements = ['height', 'chest', 'waist', 'hips', 'shoulders', 'inseam'];
      let validMeasurements = 0;

      for (const measurement of requiredMeasurements) {
        const value = measurements[measurement];
        if (value && !isNaN(Number(value))) {
          validMeasurements++;
        } else {
          warnings.push(`‚ö†Ô∏è Invalid or missing ${measurement} measurement: ${value}`);
        }
      }

      // Only fail if absolutely no valid measurements
      if (validMeasurements === 0) {
        warnings.push('‚ö†Ô∏è No valid measurements found. Using average human proportions.');
      }

      // Check measurement ranges (warn, don't fail)
      const height = Number(measurements.height);
      if (height && (height < 120 || height > 230)) {
        warnings.push(`‚ö†Ô∏è Height (${height}cm) seems unusual. Expected range: 120-230cm`);
      }
    }

    // Log warnings but don't fail validation
    if (warnings.length > 0) {
      console.log('‚ö†Ô∏è Validation warnings:', warnings);
    }

    console.log('‚úÖ Validation result: Proceeding with avatar generation');

    return {
      isValid: true, // Always return true in development mode
      errors: warnings // Return warnings as "errors" for user info
    };
  }

  /**
   * Create Google Nano Banana-compatible request from our app data
   */
  private async createNanoBananaAvatarRequest(photos: any[], measurements: any): Promise<NanoBananaGenerationRequest> {
    console.log('Creating 3D realistic avatar request from measurements:', measurements);
    console.log('Creating 3D realistic avatar request (photos optional):', photos?.length || 0);

    // Generate 3D realistic prompt based on measurements and style preferences
    const avatarConfig = environmentConfig.getAvatarGenerationConfig();
    const prompt = nanoBananaAvatarService.generate3DPrompt(measurements, avatarConfig.style, avatarConfig.perspective);

    const nanoBananaConfig = environmentConfig.getNanoBananaConfig();
    const nanoBananaRequest: NanoBananaGenerationRequest = {
      prompt,
      num_images: nanoBananaConfig.defaultNumImages,
      output_format: nanoBananaConfig.defaultOutputFormat,
      sync_mode: nanoBananaConfig.enableSyncMode
    };

    console.log('Final Nano Banana 3D avatar request:', nanoBananaRequest);
    return nanoBananaRequest;
  }

  /**
   * Generate personalized avatar using PhotoMaker
   */
  private async generatePhotoMakerAvatar(capturedPhotos: any[], measurements: any): Promise<AvatarGenerationResult> {
    try {
      this.notifyProgress({
        stage: 'Preparing personalized avatar generation',
        progress: 10,
        message: 'Processing your photos and measurements...'
      });

      // Generate personalized avatar using PhotoMaker
      const generationId = `pm_${Date.now()}`;
      this.currentGenerationId = generationId;

      this.notifyProgress({
        stage: 'Creating personalized avatar',
        progress: 30,
        message: 'Using your photos to create a personalized avatar...'
      });

      const photoMakerResponse = await photoMakerAvatarService.generatePersonalizedAvatar(
        capturedPhotos,
        measurements
      );

      this.notifyProgress({
        stage: 'Processing personalized result',
        progress: 80,
        message: 'Finalizing your personalized avatar...'
      });

      if (!photoMakerResponse.success) {
        throw new Error(photoMakerResponse.error || 'PhotoMaker generation failed');
      }

      // Process the result
      const avatarConfig = environmentConfig.getAvatarGenerationConfig();
      const cgiConfig = environmentConfig.getCGIEnhancementConfig();
      const personalizedAvatarData = photoMakerAvatarService.processPersonalizedAvatarResult(
        photoMakerResponse,
        `Personalized portrait with ${capturedPhotos?.length || 0} reference photos`,
        avatarConfig.style,
        capturedPhotos?.length || 0,
        avatarConfig.perspective,
        cgiConfig.qualityPreset
      );

      if (!personalizedAvatarData) {
        throw new Error('Failed to process personalized avatar result');
      }

      this.notifyProgress({
        stage: 'Personalized avatar complete',
        progress: 100,
        message: 'Your personalized avatar is ready! üéâ'
      });

      return this.convertPersonalizedAvatarToResult(personalizedAvatarData);

    } catch (error) {
      console.warn('‚ö†Ô∏è PhotoMaker API failed, falling back to development mode:', error);
      const cgiConfig = environmentConfig.getCGIEnhancementConfig();
      return await this.generateFallbackPersonalizedAvatar(capturedPhotos, measurements, cgiConfig.qualityPreset);
    }
  }

  /**
   * Generate avatar using Nano Banana Edit for CGI photo enhancement
   */
  private async generateNanoBananaEditAvatar(capturedPhotos: any[], measurements: any): Promise<AvatarGenerationResult> {
    try {
      this.notifyProgress({
        stage: 'Preparing CGI photo enhancement',
        progress: 10,
        message: 'Processing your photos for CGI transformation...'
      });

      // Generate enhanced 3D avatar using Nano Banana Edit
      const generationId = `nbe_${Date.now()}`;
      this.currentGenerationId = generationId;

      this.notifyProgress({
        stage: 'Transforming photos into CGI',
        progress: 30,
        message: 'Applying professional 3D CGI enhancement to your photos...'
      });

      const nanoBananaEditResponse = await nanoBananaEditService.generateEnhanced3DAvatar(
        capturedPhotos,
        measurements
      );

      this.notifyProgress({
        stage: 'Processing CGI enhancement result',
        progress: 80,
        message: 'Finalizing your CGI-enhanced avatar...'
      });

      if (!nanoBananaEditResponse.success) {
        throw new Error(nanoBananaEditResponse.error || 'Nano Banana Edit generation failed');
      }

      // Process the result
      const avatarConfig = environmentConfig.getAvatarGenerationConfig();
      const cgiConfig = environmentConfig.getCGIEnhancementConfig();
      const enhancedAvatarData = nanoBananaEditService.processEnhanced3DAvatar(
        nanoBananaEditResponse,
        `CGI-enhanced avatar with ${capturedPhotos?.length || 0} reference photos`,
        avatarConfig.style,
        capturedPhotos?.length || 0,
        avatarConfig.perspective,
        cgiConfig.qualityPreset
      );

      if (!enhancedAvatarData) {
        throw new Error('Failed to process CGI enhancement result');
      }

      this.notifyProgress({
        stage: 'CGI enhancement complete',
        progress: 100,
        message: 'Your CGI-enhanced avatar is ready! üé®'
      });

      return this.convertEnhancedAvatarToResult(enhancedAvatarData);

    } catch (error) {
      console.warn('‚ö†Ô∏è Nano Banana Edit API failed, falling back to development mode:', error);
      const cgiConfig = environmentConfig.getCGIEnhancementConfig();
      return await this.generateFallbackEnhancedAvatar(capturedPhotos, measurements, cgiConfig.qualityPreset);
    }
  }

  /**
   * Generate avatar using ByteDance Seedream for photo-to-CGI transformation
   */
  private async generateByteDanceAvatar(capturedPhotos: any[], measurements: any): Promise<AvatarGenerationResult> {
    try {
      this.notifyProgress({
        stage: 'Preparing photo-to-CGI transformation',
        progress: 10,
        message: 'Processing your photos for realistic CGI conversion...'
      });

      // Validate that we have photos
      if (!capturedPhotos || capturedPhotos.length === 0) {
        throw new Error('ByteDance Seedream requires at least one photo for transformation');
      }

      // Try using data URLs directly first (fal.ai often supports this)
      this.notifyProgress({
        stage: 'Preparing photos for CGI processing',
        progress: 15,
        message: 'Processing your photos for ByteDance API...'
      });

      // Extract and optimize data URLs from captured photos
      const photoUrls = await Promise.all(
        capturedPhotos
          .map(photo => this.getPhotoUrl(photo))
          .filter(url => url && url.length > 0)
          .map(url => this.optimizeImageForAPI(url))
      );

      if (photoUrls.length === 0) {
        throw new Error('No valid photo URLs found for ByteDance transformation');
      }

      console.log(`üì∏ Using ${photoUrls.length} optimized photos for CGI generation`);

      // Log the type of URLs and their sizes
      const hasDataUrls = photoUrls.some(url => url.startsWith('data:'));
      const hasHttpUrls = photoUrls.some(url => url.startsWith('http'));
      const avgSize = photoUrls.reduce((sum, url) => sum + url.length, 0) / photoUrls.length;
      console.log(`üîó URL types: data URLs: ${hasDataUrls}, HTTP URLs: ${hasHttpUrls}`);
      console.log(`üìè Average optimized image size: ${Math.round(avgSize / 1024)}KB`);

      const generationId = `bd_${Date.now()}`;
      this.currentGenerationId = generationId;

      this.notifyProgress({
        stage: 'Creating personalized CGI avatar',
        progress: 25,
        message: 'Transforming your photo into photorealistic 3D CGI while preserving likeness...'
      });

      // Convert measurements to ByteDance format
      const cgiMeasurements = this.convertToCGIMeasurements(measurements);
      const avatarConfig = environmentConfig.getAvatarGenerationConfig();

      const byteDanceResponse = await byteDanceSeedreamService.generateCGIFromPhoto(
        photoUrls,
        cgiMeasurements,
        avatarConfig.style as any,
        avatarConfig.perspective as any
      );

      this.notifyProgress({
        stage: 'Processing CGI transformation result',
        progress: 80,
        message: 'Finalizing your personalized CGI avatar...'
      });

      // Process the result
      const cgiConfig = environmentConfig.getCGIEnhancementConfig();
      const byteDanceAvatarData = this.processByteDanceResult(
        byteDanceResponse,
        `Personalized CGI avatar from photo transformation`,
        avatarConfig.style,
        capturedPhotos.length,
        avatarConfig.perspective,
        cgiConfig.qualityPreset
      );

      this.notifyProgress({
        stage: 'Photo-to-CGI transformation complete',
        progress: 100,
        message: 'Your personalized CGI avatar is ready! üé≠'
      });

      const result = this.convertByteDanceAvatarToResult(byteDanceAvatarData);
      return result;

    } catch (error) {
      console.error('‚ùå ByteDance Seedream API failed:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      throw new Error(`ByteDance Seedream generation failed: ${errorMessage}`);
    }
  }

  /**
   * Generate avatar using Gemini 2.5 Flash Image for 3D CGI
   */
  private async generateGeminiCGIAvatar(measurements: any, capturedPhotos: any[]): Promise<AvatarGenerationResult> {
    try {
      this.notifyProgress({
        stage: 'Preparing 3D CGI generation',
        progress: 10,
        message: 'Analyzing measurements for professional 3D CGI rendering...'
      });

      // Generate 3D CGI avatar using Gemini 2.5 Flash Image
      const generationId = `gcgi_${Date.now()}`;
      this.currentGenerationId = generationId;

      this.notifyProgress({
        stage: 'Creating 3D CGI avatar',
        progress: 30,
        message: 'Generating photorealistic 3D CGI character with animation studio quality...'
      });

      const geminiCGIResponse = await geminiCGIService.generate3DCGIAvatar(
        measurements,
        capturedPhotos
      );

      this.notifyProgress({
        stage: 'Processing 3D CGI result',
        progress: 80,
        message: 'Finalizing your professional 3D CGI avatar...'
      });

      if (!geminiCGIResponse.success) {
        throw new Error(geminiCGIResponse.error || 'Gemini CGI generation failed');
      }

      // Process the result
      const avatarConfig = environmentConfig.getAvatarGenerationConfig();
      const cgiConfig = environmentConfig.getCGIEnhancementConfig();
      const cgiAvatarData = geminiCGIService.process3DCGIResult(
        geminiCGIResponse,
        `Professional 3D CGI avatar generated from measurements`,
        avatarConfig.style,
        !!measurements,
        avatarConfig.perspective,
        cgiConfig.qualityPreset
      );

      if (!cgiAvatarData) {
        throw new Error('Failed to process 3D CGI generation result');
      }

      this.notifyProgress({
        stage: '3D CGI generation complete',
        progress: 100,
        message: 'Your professional 3D CGI avatar is ready! üé¨'
      });

      return this.convertCGIAvatarToResult(cgiAvatarData);

    } catch (error) {
      console.warn('‚ö†Ô∏è Gemini CGI API failed, falling back to development mode:', error);
      const cgiConfig = environmentConfig.getCGIEnhancementConfig();
      return await this.generateFallback3DCGIAvatar(measurements, cgiConfig.qualityPreset);
    }
  }

  /**
   * Generate avatar using Nano Banana (fallback for text-only)
   */
  private async generateNanoBananaAvatar(capturedPhotos: any[], measurements: any): Promise<AvatarGenerationResult> {
    this.notifyProgress({
      stage: 'Preparing text-to-image generation',
      progress: 10,
      message: 'Creating description from measurements...'
    });

    const nanoBananaRequest = await this.createNanoBananaAvatarRequest(capturedPhotos, measurements);

    // Validate the request
    const requestValidation = nanoBananaAvatarService.validateConfiguration();
    if (!requestValidation.isValid) {
      console.warn('‚ö†Ô∏è Nano Banana API configuration issues:', requestValidation.errors);
    }

    try {
      const generationId = `nb_${Date.now()}`;
      this.currentGenerationId = generationId;

      this.notifyProgress({
        stage: 'Text-to-image generation in progress',
        progress: 30,
        message: 'Creating avatar from description...'
      });

      const nanoBananaResponse = await nanoBananaAvatarService.generate3DAvatar(nanoBananaRequest);

      this.notifyProgress({
        stage: 'Processing text-to-image result',
        progress: 80,
        message: 'Finalizing your avatar...'
      });

      if (!nanoBananaResponse.success) {
        throw new Error(nanoBananaResponse.error || 'Nano Banana generation failed');
      }

      const avatar3DData = nanoBananaAvatarService.process3DAvatarResult(
        nanoBananaResponse,
        nanoBananaRequest.prompt,
        import.meta.env.VITE_DEFAULT_AVATAR_STYLE || 'realistic'
      );

      if (!avatar3DData) {
        throw new Error('Failed to process Nano Banana avatar result');
      }

      return this.convert3DAvatarToResult(avatar3DData);

    } catch (apiError) {
      console.warn('‚ö†Ô∏è Nano Banana API failed, falling back to preview:', apiError);
      return await this.generateFallback3DAvatar(capturedPhotos, measurements);
    }
  }

  /**
   * Convert 3D avatar data to our result format
   */
  private convert3DAvatarToResult(avatar3DData: Avatar3DData): AvatarGenerationResult {
    return {
      success: true,
      avatarData: {
        imageUrl: avatar3DData.imageUrl,
        description: avatar3DData.description,
        previewUrl: avatar3DData.imageUrl, // Use primary image as preview
        metadata: {
          prompt: avatar3DData.metadata.prompt,
          style: avatar3DData.metadata.style,
          quality: avatar3DData.metadata.quality,
          generation_time: avatar3DData.metadata.generation_time,
          model: avatar3DData.metadata.model,
          perspective: avatar3DData.metadata.perspective,
          lighting: avatar3DData.metadata.lighting
        },
        qualityScore: avatar3DData.qualityScore
      }
    };
  }

  /**
   * Convert personalized avatar data to our result format
   */
  private convertPersonalizedAvatarToResult(personalizedAvatarData: PersonalizedAvatar3DData): AvatarGenerationResult {
    return {
      success: true,
      avatarData: {
        imageUrl: personalizedAvatarData.imageUrl,
        description: personalizedAvatarData.description,
        previewUrl: personalizedAvatarData.imageUrl, // Use primary image as preview
        metadata: {
          prompt: personalizedAvatarData.metadata.prompt,
          style: personalizedAvatarData.metadata.style,
          quality: personalizedAvatarData.metadata.quality,
          generation_time: personalizedAvatarData.metadata.generation_time,
          model: personalizedAvatarData.metadata.model,
          perspective: personalizedAvatarData.metadata.perspective,
          lighting: personalizedAvatarData.metadata.lighting,
          // PhotoMaker-specific metadata
          personalization: personalizedAvatarData.metadata.personalization,
          reference_photos_count: personalizedAvatarData.metadata.reference_photos_count
        },
        qualityScore: personalizedAvatarData.qualityScore
      }
    };
  }

  /**
   * Convert Enhanced3DAvatar to AvatarGenerationResult format
   */
  private convertEnhancedAvatarToResult(enhancedAvatarData: Enhanced3DAvatar): AvatarGenerationResult {
    return {
      success: true,
      avatarData: {
        imageUrl: enhancedAvatarData.imageUrl,
        description: enhancedAvatarData.description,
        previewUrl: enhancedAvatarData.imageUrl, // Use primary image as preview
        metadata: {
          prompt: enhancedAvatarData.metadata.prompt,
          style: enhancedAvatarData.metadata.style,
          quality: enhancedAvatarData.metadata.quality,
          generation_time: enhancedAvatarData.metadata.generation_time,
          model: enhancedAvatarData.metadata.model,
          perspective: enhancedAvatarData.metadata.perspective,
          lighting: enhancedAvatarData.metadata.lighting,
          // Nano Banana Edit-specific metadata
          enhancement_type: enhancedAvatarData.metadata.enhancement_type,
          reference_photos_count: enhancedAvatarData.metadata.reference_photos_count,
          cgi_preset: enhancedAvatarData.metadata.cgi_preset,
          strength: enhancedAvatarData.metadata.strength
        },
        qualityScore: enhancedAvatarData.qualityScore
      }
    };
  }

  /**
   * Convert CGI3DAvatar to AvatarGenerationResult format
   */
  private convertCGIAvatarToResult(cgiAvatarData: CGI3DAvatar): AvatarGenerationResult {
    return {
      success: true,
      avatarData: {
        imageUrl: cgiAvatarData.imageUrl,
        description: cgiAvatarData.description,
        previewUrl: cgiAvatarData.imageUrl, // Use primary image as preview
        metadata: {
          prompt: cgiAvatarData.metadata.prompt,
          style: cgiAvatarData.metadata.style,
          quality: cgiAvatarData.metadata.quality,
          generation_time: cgiAvatarData.metadata.generation_time,
          model: cgiAvatarData.metadata.model,
          perspective: cgiAvatarData.metadata.perspective,
          lighting: cgiAvatarData.metadata.lighting,
          // Gemini CGI-specific metadata
          generation_type: cgiAvatarData.metadata.generation_type,
          measurements_used: cgiAvatarData.metadata.measurements_used,
          cgi_preset: cgiAvatarData.metadata.cgi_preset,
          cgi_features: cgiAvatarData.metadata.cgi_features,
          technical_specs: cgiAvatarData.metadata.technical_specs
        },
        qualityScore: cgiAvatarData.qualityScore
      }
    };
  }

  /**
   * Extract photo URL from captured photo data
   */
  private getPhotoUrl(photo: any): string | null {
    if (!photo) return null;

    // Try different URL properties in order of preference
    if (photo.url) return photo.url;           // HTTP URL (preferred)
    if (photo.dataUrl) return photo.dataUrl;   // Base64 data URL (fallback)
    if (photo.blob) {
      // Convert blob to data URL
      return URL.createObjectURL(photo.blob);
    }

    return null;
  }

  /**
   * Convert measurements to ByteDance CGI format
   */
  private convertToCGIMeasurements(measurements: any): Partial<CGIMeasurements> {
    if (!measurements) return {};

    return {
      height: Number(measurements.height) || undefined,
      bust: Number(measurements.bust) || Number(measurements.chest) || undefined,
      waist: Number(measurements.waist) || undefined,
      hips: Number(measurements.hips) || undefined,
      shoulders: Number(measurements.shoulders) || undefined,
      chest: Number(measurements.chest) || undefined,
      inseam: Number(measurements.inseam) || undefined,
      neck: Number(measurements.neck) || undefined,
      bicep: Number(measurements.bicep) || undefined,
      forearm: Number(measurements.forearm) || undefined,
      thigh: Number(measurements.thigh) || undefined,
      calf: Number(measurements.calf) || undefined
    };
  }

  /**
   * Process ByteDance Seedream response
   */
  private processByteDanceResult(
    response: ByteDanceSeedreamResponse,
    description: string,
    style: string,
    photoCount: number,
    perspective: string,
    cgiPreset: string
  ) {
    const primaryImage = response.images[0];
    if (!primaryImage) {
      throw new Error('No images in ByteDance response');
    }

    return {
      imageUrl: primaryImage.url,
      description,
      metadata: {
        prompt: description,
        style,
        quality: cgiPreset,
        generation_time: response.timings?.inference || 0,
        model: 'ByteDance Seedream 4.0',
        perspective,
        lighting: 'Professional CGI lighting',
        // ByteDance-specific metadata
        generation_type: 'photo_to_cgi',
        reference_photos_count: photoCount,
        cgi_preset: cgiPreset,
        image_size: `${primaryImage.width}x${primaryImage.height}`,
        seed: response.seed || 42
      },
      qualityScore: 95 // High quality for photo-to-CGI transformation
    };
  }

  /**
   * Convert ByteDance avatar data to result format
   */
  private convertByteDanceAvatarToResult(byteDanceAvatarData: any): AvatarGenerationResult {
    return {
      success: true,
      avatarData: {
        imageUrl: byteDanceAvatarData.imageUrl,
        description: byteDanceAvatarData.description,
        previewUrl: byteDanceAvatarData.imageUrl,
        metadata: {
          prompt: byteDanceAvatarData.metadata.prompt,
          style: byteDanceAvatarData.metadata.style,
          quality: byteDanceAvatarData.metadata.quality,
          generation_time: byteDanceAvatarData.metadata.generation_time,
          model: byteDanceAvatarData.metadata.model,
          perspective: byteDanceAvatarData.metadata.perspective,
          lighting: byteDanceAvatarData.metadata.lighting,
          // ByteDance-specific metadata
          generation_type: byteDanceAvatarData.metadata.generation_type,
          reference_photos_count: byteDanceAvatarData.metadata.reference_photos_count,
          cgi_preset: byteDanceAvatarData.metadata.cgi_preset,
          image_size: byteDanceAvatarData.metadata.image_size,
          seed: byteDanceAvatarData.metadata.seed
        },
        qualityScore: byteDanceAvatarData.qualityScore
      }
    };
  }

  /**
   * Estimate generation time based on input complexity (updated for 3D realistic)
   */
  estimateGenerationTime(photos: any[], measurements: any): number {
    // Base time for 3D realistic generation: 90 seconds
    let estimatedTime = 90000;

    // Add time based on complexity of measurements
    if (measurements) {
      const measurementCount = Object.keys(measurements).length;
      estimatedTime += measurementCount * 2000; // 2 seconds per measurement
    }

    // Add time based on style complexity
    const style = import.meta.env.VITE_DEFAULT_AVATAR_STYLE || 'realistic';
    if (style === 'cinematic' || style === 'artistic') {
      estimatedTime += 20000; // 20 seconds for complex styles
    }

    return estimatedTime;
  }

  /**
   * Notify all progress callbacks
   */
  private notifyProgress(progress: GenerationProgress): void {
    this.progressCallbacks.forEach(callback => {
      try {
        callback(progress);
      } catch (error) {
        console.error('Error in progress callback:', error);
      }
    });
  }


  /**
   * Get current generation status
   */
  getCurrentGenerationId(): string | null {
    return this.currentGenerationId;
  }

  /**
   * Generate a fallback personalized avatar for development/demo purposes
   */
  private async generateFallbackPersonalizedAvatar(
    capturedPhotos: any[],
    measurements: any
  ): Promise<AvatarGenerationResult> {
    // Simulate personalized generation progress
    const photoCount = capturedPhotos?.length || 0;
    const steps = [
      { stage: 'Analyzing reference photos', progress: 20, message: `Processing ${photoCount} reference photos...` },
      { stage: 'Extracting facial features', progress: 40, message: 'Analyzing your unique characteristics...' },
      { stage: 'Combining with measurements', progress: 60, message: 'Integrating body measurements...' },
      { stage: 'Generating personalized avatar', progress: 80, message: 'Creating your personalized portrait...' },
      { stage: 'Finalizing personalized result', progress: 95, message: 'Almost ready...' }
    ];

    for (const step of steps) {
      this.notifyProgress(step);
      // Simulate processing time
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    this.notifyProgress({
      stage: 'Personalized avatar complete',
      progress: 100,
      message: 'Your personalized avatar is ready! üéâ'
    });

    // Use the PhotoMaker service to generate fallback personalized avatar
    const personalizedAvatarData = await photoMakerAvatarService.generateFallbackPersonalizedAvatar(capturedPhotos, measurements);

    // Convert to our result format
    return this.convertPersonalizedAvatarToResult(personalizedAvatarData);
  }

  /**
   * Generate a fallback enhanced avatar for development/demo purposes
   */
  private async generateFallbackEnhancedAvatar(
    capturedPhotos: any[],
    measurements: any,
    cgiPreset: string = 'animation_studio'
  ): Promise<AvatarGenerationResult> {
    // Simulate CGI enhancement progress
    const photoCount = capturedPhotos?.length || 0;
    const steps = [
      { stage: 'Preparing photos for CGI enhancement', progress: 15, message: `Processing ${photoCount} reference photos...` },
      { stage: 'Analyzing photo composition', progress: 30, message: 'Examining lighting and angles...' },
      { stage: 'Applying CGI transformations', progress: 50, message: 'Converting to 3D CGI rendering...' },
      { stage: 'Enhancing textures and materials', progress: 70, message: 'Adding PBR materials and subsurface scattering...' },
      { stage: 'Finalizing CGI quality', progress: 85, message: `Applying ${cgiPreset} quality preset...` },
      { stage: 'CGI enhancement complete', progress: 95, message: 'Almost ready...' }
    ];

    for (const step of steps) {
      this.notifyProgress(step);
      // Simulate processing time
      await new Promise(resolve => setTimeout(resolve, 1200));
    }

    this.notifyProgress({
      stage: 'CGI enhancement complete',
      progress: 100,
      message: 'Your CGI-enhanced avatar is ready! üé®'
    });

    // Use the Nano Banana Edit service to generate fallback enhanced avatar
    const enhancedAvatarData = await nanoBananaEditService.generateFallbackEnhancedAvatar(capturedPhotos, measurements, cgiPreset);

    // Convert to our result format
    return this.convertEnhancedAvatarToResult(enhancedAvatarData);
  }

  /**
   * Generate a fallback 3D CGI avatar for development/demo purposes
   */
  private async generateFallback3DCGIAvatar(
    measurements: any,
    cgiPreset: string = 'animation_studio'
  ): Promise<AvatarGenerationResult> {
    // Simulate 3D CGI generation progress
    const steps = [
      { stage: 'Analyzing measurements for CGI', progress: 10, message: 'Processing body measurements for 3D modeling...' },
      { stage: 'Generating CGI character description', progress: 25, message: 'Creating detailed 3D CGI specifications...' },
      { stage: 'Applying photorealistic materials', progress: 45, message: 'Adding PBR materials and subsurface scattering...' },
      { stage: 'Setting up studio lighting', progress: 65, message: 'Configuring three-point studio lighting setup...' },
      { stage: 'Rendering 3D CGI avatar', progress: 80, message: `Rendering with ${cgiPreset} quality preset...` },
      { stage: 'Post-processing CGI result', progress: 95, message: 'Applying color grading and final touches...' }
    ];

    for (const step of steps) {
      this.notifyProgress(step);
      // Simulate processing time
      await new Promise(resolve => setTimeout(resolve, 1500));
    }

    this.notifyProgress({
      stage: '3D CGI generation complete',
      progress: 100,
      message: 'Your professional 3D CGI avatar is ready! üé¨'
    });

    // Use the Gemini CGI service to generate fallback avatar
    const cgiAvatarData = await geminiCGIService.generateFallback3DCGIAvatar(measurements, cgiPreset);

    // Convert to our result format
    return this.convertCGIAvatarToResult(cgiAvatarData);
  }

  /**
   * Generate a fallback ByteDance avatar for development/demo purposes
   */
  private async generateFallbackByteDanceAvatar(
    capturedPhotos: any[],
    measurements: any,
    cgiPreset: string = 'animation_studio'
  ): Promise<AvatarGenerationResult> {
    // Simulate ByteDance photo-to-CGI transformation progress
    const photoCount = capturedPhotos?.length || 0;
    const steps = [
      { stage: 'Analyzing uploaded photos', progress: 15, message: `Processing ${photoCount} reference photos for CGI transformation...` },
      { stage: 'Detecting facial features', progress: 30, message: 'Identifying key facial landmarks and expressions...' },
      { stage: 'Preserving human likeness', progress: 45, message: 'Maintaining your unique characteristics during CGI conversion...' },
      { stage: 'Applying measurements', progress: 60, message: 'Integrating body measurements for accurate proportions...' },
      { stage: 'Generating CGI materials', progress: 75, message: 'Creating photorealistic CGI textures and lighting...' },
      { stage: 'Final CGI rendering', progress: 90, message: `Rendering with ${cgiPreset} quality preset...` }
    ];

    for (const step of steps) {
      this.notifyProgress(step);
      // Simulate processing time
      await new Promise(resolve => setTimeout(resolve, 1300));
    }

    this.notifyProgress({
      stage: 'Photo-to-CGI transformation complete',
      progress: 100,
      message: 'Your personalized CGI avatar is ready! üé≠'
    });

    // Generate fallback ByteDance avatar data
    const byteDanceAvatarData = {
      imageUrl: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=2048&h=2048&fit=crop&crop=face',
      description: `Personalized CGI avatar transformed from ${photoCount} reference photos`,
      metadata: {
        prompt: `Photo-to-CGI transformation preserving human likeness with ${Object.keys(measurements || {}).length} measurements`,
        style: 'realistic',
        quality: cgiPreset,
        generation_time: 3.2,
        model: 'ByteDance Seedream 4.0',
        perspective: 'full',
        lighting: 'Professional CGI lighting',
        generation_type: 'photo_to_cgi',
        reference_photos_count: photoCount,
        cgi_preset: cgiPreset,
        image_size: '2048x2048',
        seed: 12345
      },
      qualityScore: 95
    };

    return this.convertByteDanceAvatarToResult(byteDanceAvatarData);
  }

  /**
   * Generate a fallback 3D realistic avatar for development/demo purposes
   */
  private async generateFallback3DAvatar(
    capturedPhotos: any[],
    measurements: any
  ): Promise<AvatarGenerationResult> {
    // Simulate 3D realistic generation progress
    const steps = [
      { stage: 'Analyzing measurements', progress: 30, message: 'Processing body measurements...' },
      { stage: 'Generating 3D realistic prompt', progress: 50, message: 'Creating photorealistic description...' },
      { stage: 'Rendering 3D portrait', progress: 70, message: 'Building your 3D realistic avatar...' },
      { stage: 'Applying realistic lighting', progress: 85, message: 'Adding volumetric lighting...' },
      { stage: 'Finalizing 3D avatar', progress: 95, message: 'Almost ready...' }
    ];

    for (const step of steps) {
      this.notifyProgress(step);
      // Simulate processing time
      await new Promise(resolve => setTimeout(resolve, 800));
    }

    this.notifyProgress({
      stage: '3D realistic avatar complete',
      progress: 100,
      message: 'Your photorealistic 3D avatar is ready! üéâ'
    });

    // Use the Nano Banana service to generate fallback 3D avatar
    const avatar3DData = await nanoBananaAvatarService.generateFallback3DAvatar(measurements);

    // Convert to our result format
    return this.convert3DAvatarToResult(avatar3DData);
  }

  /**
   * Check if generation is in progress
   */
  isGenerating(): boolean {
    return this.currentGenerationId !== null;
  }

  /**
   * Optimize image size for API to avoid 413 payload too large errors
   */
  private async optimizeImageForAPI(dataUrl: string): Promise<string> {
    if (!dataUrl.startsWith('data:')) {
      return dataUrl; // Not a data URL, return as-is
    }

    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d')!;

        // Much more aggressive compression to avoid HTTP 413 errors
        // Target max 150KB per image (450KB total for 3 images)
        const maxSize = 512; // Reduced from 800 to 512
        let { width, height } = img;

        if (width > height) {
          if (width > maxSize) {
            height = (height * maxSize) / width;
            width = maxSize;
          }
        } else {
          if (height > maxSize) {
            width = (width * maxSize) / height;
            height = maxSize;
          }
        }

        canvas.width = width;
        canvas.height = height;

        // Draw and compress more aggressively (quality 0.6 instead of 0.8)
        ctx.drawImage(img, 0, 0, width, height);
        let optimizedDataUrl = canvas.toDataURL('image/jpeg', 0.6);

        // If still too large, compress further
        let quality = 0.6;
        while (optimizedDataUrl.length > 150000 && quality > 0.3) { // Target 150KB max
          quality -= 0.1;
          optimizedDataUrl = canvas.toDataURL('image/jpeg', quality);
        }

        console.log(`üîß Image optimized: ${Math.round(dataUrl.length / 1024)}KB ‚Üí ${Math.round(optimizedDataUrl.length / 1024)}KB (quality: ${quality.toFixed(1)})`);
        resolve(optimizedDataUrl);
      };

      img.onerror = () => {
        console.warn('‚ö†Ô∏è Failed to optimize image, using original');
        resolve(dataUrl);
      };

      img.src = dataUrl;
    });
  }
}

// Export singleton instance
export const avatarGenerationService = new AvatarGenerationService();
export default avatarGenerationService;