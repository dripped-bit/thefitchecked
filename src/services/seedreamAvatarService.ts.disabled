/**
 * ByteDance Seedream 4.0 Avatar Service
 * Handles 2D CGI realistic avatar generation using fal.ai API
 */


export interface SeedreamGenerationRequest {
  prompt: string;
  imageUrls: string[];
  imageSize?: {
    width: number;
    height: number;
  };
  numImages?: number;
  seed?: number;
  enableSafetyChecker?: boolean;
}

export interface SeedreamGenerationResponse {
  success: boolean;
  images?: Array<{
    url: string;
  }>;
  seed?: number;
  error?: string;
}

export interface Avatar2DData {
  imageUrl: string;
  enhancedImageUrl?: string;
  metadata: {
    seed: number;
    prompt: string;
    style: string;
    quality: string;
    generation_time: number;
  };
  qualityScore: number;
}

export class SeedreamAvatarService {
  private readonly MODEL_ID = 'fal-ai/bytedance/seedream/v4/edit';
  private readonly DEFAULT_IMAGE_SIZE = { width: 2048, height: 2048 };

  /**
   * Generate local SVG placeholder to replace external via.placeholder.com
   */
  private generateSVGPlaceholder(text: string, width: number = 512, height: number = 512): string {
    // Sanitize text to ASCII-only
    const safeText = text.replace(/[^\x00-\x7F]/g, "").trim() || 'Avatar';

    const svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg"><rect width="100%" height="100%" fill="#E5E7EB"/><rect x="10%" y="10%" width="80%" height="80%" fill="#F3F4F6" stroke="#D1D5DB" stroke-width="2" rx="8"/><text x="50%" y="45%" text-anchor="middle" font-family="system-ui, sans-serif" font-size="18" fill="#6B7280">${safeText}</text><text x="50%" y="65%" text-anchor="middle" font-family="system-ui, sans-serif" font-size="12" fill="#9CA3AF">Avatar Photo</text></svg>`;

    try {
      // Try standard btoa first
      return `data:image/svg+xml;base64,${btoa(svg.trim())}`;
    } catch (error) {
      console.log('üîÑ [SEEDREAM] Using UTF-8 safe encoding fallback');
      try {
        // UTF-8 safe encoding
        const base64 = btoa(encodeURIComponent(svg).replace(/%([0-9A-F]{2})/g,
          (match, p1) => String.fromCharCode(parseInt('0x' + p1, 16))));
        return `data:image/svg+xml;base64,${base64}`;
      } catch (finalError) {
        console.warn('‚ö†Ô∏è [SEEDREAM] All encoding failed, using URL encoding:', finalError);
        return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
      }
    }
  }

  /**
   * Generate 2D CGI realistic avatar using ByteDance Seedream 4.0
   */
  async generateCGIAvatar(request: SeedreamGenerationRequest): Promise<SeedreamGenerationResponse> {
    try {
      console.log('üé® Starting Seedream CGI avatar generation');
      console.log('üìù Prompt:', request.prompt);
      console.log('üñºÔ∏è Input images:', request.imageUrls.length);

      // Validate inputs
      if (!request.prompt || request.prompt.trim().length === 0) {
        throw new Error('Prompt is required for CGI avatar generation');
      }

      if (!request.imageUrls || request.imageUrls.length === 0) {
        throw new Error('At least one image URL is required');
      }

      // Prepare request for ByteDance Seedream API
      const seedreamRequest = {
        prompt: request.prompt,
        image_urls: request.imageUrls,
        image_size: request.imageSize || this.DEFAULT_IMAGE_SIZE,
        num_images: request.numImages || 1,
        seed: request.seed,
        enable_safety_checker: request.enableSafetyChecker ?? true,
        sync_mode: true // Wait for completion
      };

      console.log('üöÄ Sending request to ByteDance Seedream API');
      const startTime = Date.now();

      // Call ByteDance Seedream API via fal.ai
      const { fal } = await import('@fal-ai/client');

      const result = await fal.subscribe(this.MODEL_ID, {
        input: seedreamRequest,
        logs: true,
        onQueueUpdate: (update) => {
          if (update.status === 'IN_PROGRESS') {
            update.logs?.map((log) => log.message).forEach(console.log);
          }
        },
      });

      const generationTime = Date.now() - startTime;
      console.log(`‚úÖ CGI avatar generation completed in ${generationTime}ms`);

      if (!result.data || !result.data.images || result.data.images.length === 0) {
        throw new Error('No images generated by Seedream API');
      }

      return {
        success: true,
        images: result.data.images,
        seed: result.data.seed
      };

    } catch (error) {
      console.error('‚ùå ByteDance Seedream generation failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
  }

  /**
   * Generate prompt for CGI avatar based on photos and measurements
   */
  generateCGIPrompt(measurements: any, photoCount: number, style: string = 'realistic'): string {
    console.log('üî§ Generating CGI prompt from measurements:', measurements);

    // Base prompt for high-quality CGI
    let prompt = 'Professional CGI portrait of a person with ';

    // Add physical characteristics from measurements
    if (measurements) {
      // Height-based build description
      const height = Number(measurements.height) || 170;
      if (height < 160) {
        prompt += 'petite build, ';
      } else if (height > 185) {
        prompt += 'tall stature, ';
      } else {
        prompt += 'average height, ';
      }

      // Body proportions
      const chest = Number(measurements.chest) || 90;
      const waist = Number(measurements.waist) || 80;
      const ratio = chest / waist;

      if (ratio > 1.3) {
        prompt += 'athletic build, ';
      } else if (ratio < 1.1) {
        prompt += 'slender frame, ';
      } else {
        prompt += 'proportioned physique, ';
      }

      // Gender-based styling
      if (measurements.gender) {
        prompt += `${measurements.gender.toLowerCase()} features, `;
      }
    }

    // Style specifications
    switch (style.toLowerCase()) {
      case 'realistic':
        prompt += 'photorealistic CGI rendering, natural lighting, high detail, professional photography quality, ';
        break;
      case 'artistic':
        prompt += 'artistic CGI rendering, dramatic lighting, stylized features, creative composition, ';
        break;
      case 'professional':
        prompt += 'professional headshot style, studio lighting, business attire, clean background, ';
        break;
      default:
        prompt += 'high-quality CGI rendering, balanced lighting, detailed features, ';
    }

    // Technical quality specifications
    prompt += 'sharp focus, high resolution, detailed textures, realistic skin, natural hair, ';
    prompt += 'professional CGI quality, rendered with advanced graphics, photorealistic materials, ';
    prompt += 'studio lighting setup, clean composition, no artifacts or distortions';

    // Add photo count context
    if (photoCount > 1) {
      prompt += `. Synthesize features from ${photoCount} reference images for accurate representation.`;
    }

    console.log('‚úÖ Generated CGI prompt:', prompt);
    return prompt;
  }

  /**
   * Convert data URLs to temporary URLs for API consumption
   */
  async prepareImageUrls(photos: any[]): Promise<string[]> {
    console.log('üîÑ Preparing image URLs for Seedream API');

    const imageUrls: string[] = [];

    for (const photo of photos) {
      try {
        if (photo.dataUrl) {
          // For development, we'll use local SVG placeholders
          // In production, you'd upload to a CDN and get real URLs
          const placeholderUrl = this.generateSVGPlaceholder(`Photo-${photo.view || 'unknown'}`, 512, 512);
          imageUrls.push(placeholderUrl);
          console.log(`üì∏ Added local SVG placeholder for ${photo.view} photo`);
        } else if (photo.url) {
          imageUrls.push(photo.url);
          console.log(`üì∏ Added existing URL for ${photo.view} photo`);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Failed to process photo ${photo.view}:`, error);
      }
    }

    if (imageUrls.length === 0) {
      // Fallback to demo images for development
      imageUrls.push(
        'https://storage.googleapis.com/falserverless/example_inputs/seedream4_edit_input_1.png'
      );
      console.log('üîÑ Using demo image as fallback');
    }

    console.log(`‚úÖ Prepared ${imageUrls.length} image URLs for API`);
    return imageUrls;
  }

  /**
   * Process the generated CGI avatar result
   */
  processAvatarResult(
    response: SeedreamGenerationResponse,
    prompt: string,
    style: string
  ): Avatar2DData | null {
    if (!response.success || !response.images || response.images.length === 0) {
      return null;
    }

    const primaryImage = response.images[0];
    const qualityScore = this.calculateQualityScore(response, prompt);

    return {
      imageUrl: primaryImage.url,
      metadata: {
        seed: response.seed || Math.floor(Math.random() * 1000000),
        prompt,
        style,
        quality: 'high',
        generation_time: Date.now()
      },
      qualityScore
    };
  }

  /**
   * Calculate quality score based on generation results
   */
  private calculateQualityScore(response: SeedreamGenerationResponse, prompt: string): number {
    let score = 85; // Base score

    // Bonus for successful generation
    if (response.success && response.images && response.images.length > 0) {
      score += 10;
    }

    // Bonus for detailed prompt
    if (prompt.length > 100) {
      score += 5;
    }

    // Bonus for seed consistency (deterministic results)
    if (response.seed) {
      score += 5;
    }

    return Math.min(100, score);
  }

  /**
   * Generate fallback 2D avatar for development/demo
   */
  async generateFallback2DAvatar(measurements: any, photos: any[]): Promise<Avatar2DData> {
    console.log('üé≠ Generating fallback 2D avatar for development');

    // Simulate processing time
    await new Promise(resolve => setTimeout(resolve, 1000));

    const prompt = this.generateCGIPrompt(measurements, photos.length);

    return {
      imageUrl: '', // No placeholder - empty state will be shown
      metadata: {
        seed: Math.floor(Math.random() * 1000000),
        prompt,
        style: 'realistic',
        quality: 'demo',
        generation_time: Date.now()
      },
      qualityScore: 75
    };
  }

  /**
   * Validate API configuration
   */
  validateConfiguration(): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check if fal.ai client is configured
    try {
      if (!import.meta.env.VITE_FAL_KEY && !import.meta.env.FAL_KEY) {
        errors.push('VITE_FAL_KEY environment variable is not set');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Environment variable check failed, proceeding with development mode');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// Export singleton instance
export const seedreamAvatarService = new SeedreamAvatarService();
export default seedreamAvatarService;