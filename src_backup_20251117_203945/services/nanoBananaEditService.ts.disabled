/**
 * Nano Banana Edit Service
 * Handles image-to-image transformation for enhanced 3D realistic avatar generation
 * Uses Nano Banana Edit model via fal.ai API for CGI photo enhancement
 */

import { environmentConfig } from './environmentConfig';
import { cgiPromptEnhancer } from './cgiPromptEnhancer';

export interface NanoBananaEditRequest {
  image_urls: string[];
  prompt: string;
  negative_prompt?: string;
  strength?: number;
  guidance_scale?: number;
  num_inference_steps?: number;
  num_images?: number;
  seed?: number;
  enable_safety_checker?: boolean;
  output_format?: 'jpeg' | 'png';
  sync_mode?: boolean;
}

export interface NanoBananaEditResponse {
  success: boolean;
  images?: Array<{
    url: string;
    width: number;
    height: number;
    file_size: number;
    file_name: string;
    content_type: string;
  }>;
  seed?: number;
  error?: string;
}

export interface Enhanced3DAvatar {
  imageUrl: string;
  description?: string;
  metadata: {
    prompt: string;
    style: string;
    quality: string;
    generation_time: number;
    model: string;
    perspective: string;
    lighting: string;
    enhancement_type: 'cgi_photo_enhancement';
    reference_photos_count: number;
    // CGI-specific metadata
    cgi_preset?: string;
    cgi_features?: string[];
    technical_specs?: Record<string, any>;
    strength?: number;
  };
  qualityScore: number;
}

export class NanoBananaEditService {
  private readonly config = environmentConfig.getNanoBananaEditConfig();

  /**
   * Generate enhanced 3D CGI avatar using photo enhancement
   */
  async generateEnhanced3DAvatar(
    capturedPhotos: any[],
    measurements: any,
    request: Partial<NanoBananaEditRequest> = {}
  ): Promise<NanoBananaEditResponse> {
    try {
      console.log('üé® Starting Nano Banana Edit CGI photo enhancement');
      console.log('üì∏ Reference photos:', capturedPhotos?.length || 0);
      console.log('üìè Measurements:', measurements);

      // Step 1: Convert captured photos to URLs
      const imageUrls = await this.prepareImageUrls(capturedPhotos);

      if (!imageUrls || imageUrls.length === 0) {
        throw new Error('No valid photos provided for CGI enhancement. Please ensure photos are captured.');
      }

      // Step 2: Generate detailed 3D CGI prompt from measurements
      const cgiConfig = environmentConfig.getCGIEnhancementConfig();
      const avatarConfig = environmentConfig.getAvatarGenerationConfig();
      const prompt = this.generateCGIEnhancementPrompt(
        measurements,
        avatarConfig.style,
        avatarConfig.perspective,
        cgiConfig.qualityPreset
      );

      // Step 3: Prepare Nano Banana Edit request
      const nanoBananaEditRequest: NanoBananaEditRequest = {
        image_urls: imageUrls,
        prompt,
        strength: request.strength || 0.8, // High strength for significant CGI enhancement
        guidance_scale: request.guidance_scale || 7.5,
        num_inference_steps: request.num_inference_steps || 30,
        num_images: request.num_images || this.config.defaultNumImages,
        negative_prompt: 'low quality, blurry, distorted, unrealistic, bad anatomy, low resolution, pixelated, artifacts',
        enable_safety_checker: true,
        output_format: this.config.defaultOutputFormat,
        sync_mode: this.config.enableSyncMode
      };

      console.log('üöÄ Sending request to Nano Banana Edit API');
      console.log('üñºÔ∏è Processing', imageUrls.length, 'reference photos');
      const startTime = Date.now();

      // Step 4: DISABLED - fal-ai dependencies removed
      // const { fal } = await import('@fal-ai/client');
      console.error('‚ùå Nano Banana Edit service disabled - fal-ai dependencies removed');
      throw new Error('Nano Banana Edit service temporarily disabled');
        input: nanoBananaEditRequest,
        logs: true,
        onQueueUpdate: (update) => {
          if (update.status === 'IN_PROGRESS') {
            update.logs?.map((log) => log.message).forEach(console.log);
          }
        },
      });

      const generationTime = Date.now() - startTime;
      console.log(`‚úÖ Nano Banana Edit CGI enhancement completed in ${generationTime}ms`);

      if (!result.data || !result.data.images || result.data.images.length === 0) {
        throw new Error('No enhanced images generated by Nano Banana Edit API');
      }

      return {
        success: true,
        images: result.data.images,
        seed: result.data.seed
      };

    } catch (error) {
      console.error('‚ùå Nano Banana Edit generation failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
  }

  /**
   * Prepare image URLs from captured photos for Nano Banana Edit
   */
  private async prepareImageUrls(capturedPhotos: any[]): Promise<string[]> {
    if (!capturedPhotos || capturedPhotos.length === 0) {
      console.log('üì∏ No photos provided for CGI enhancement');
      return [];
    }

    try {
      console.log('üì¶ Preparing image URLs for Nano Banana Edit...');

      // Filter valid photos
      const validPhotos = capturedPhotos.filter(photo => {
        return photo && (photo.blob || photo.file || photo.dataUrl || photo.url);
      });

      if (validPhotos.length === 0) {
        console.warn('‚ö†Ô∏è No valid photo data found for URL preparation');
        return [];
      }

      console.log(`üì∏ Found ${validPhotos.length} valid photos for CGI enhancement`);

      // Convert photos to URLs
      const imageUrls: string[] = [];

      for (const photo of validPhotos) {
        if (photo.url) {
          // Already has URL
          imageUrls.push(photo.url);
        } else if (photo.dataUrl) {
          // For now, use data URLs directly (Nano Banana Edit should support them)
          // In production, you'd upload to cloud storage and get HTTP URLs
          imageUrls.push(photo.dataUrl);
        } else {
          console.warn('‚ö†Ô∏è Photo format not supported for URL conversion:', photo);
        }
      }

      // For development/demo, also include demo URLs if no valid photos
      if (imageUrls.length === 0) {
        console.log('üîß No convertible photos found, using demo URLs for development');
        // Demo portrait photos for testing
        imageUrls.push(
          'https://storage.googleapis.com/falserverless/model_tests/nano-banana-edit/demo-portrait-1.jpg'
        );
      }

      console.log(`‚úÖ Prepared ${imageUrls.length} image URLs for Nano Banana Edit`);
      return imageUrls;

    } catch (error) {
      console.error('‚ùå Failed to prepare image URLs:', error);
      return [];
    }
  }

  /**
   * Generate detailed 3D CGI enhancement prompt
   */
  generateCGIEnhancementPrompt(
    measurements: any,
    style: string = 'realistic',
    perspective: string = 'portrait',
    cgiPreset: string = 'animation_studio'
  ): string {
    console.log('üî§ Generating detailed 3D CGI enhancement prompt');
    console.log('üé¨ CGI Preset:', cgiPreset);

    // Use CGI prompt enhancer to generate professional 3D CGI prompt
    const cgiPrompt = cgiPromptEnhancer.generateCGIPromptForAvatar(
      measurements,
      style,
      perspective,
      cgiPreset
    );

    // Add image-to-image specific instructions
    const enhancementPrompt = `Transform this portrait photo into: ${cgiPrompt}`;

    console.log('‚úÖ Generated CGI enhancement prompt:', enhancementPrompt);
    return enhancementPrompt;
  }

  /**
   * Generate basic CGI enhancement prompt (fallback)
   */
  generateBasicEnhancementPrompt(
    measurements: any,
    style: string = 'realistic',
    perspective: string = 'portrait'
  ): string {
    console.log('üî§ Generating basic CGI enhancement prompt');

    // Base prompt for image-to-image CGI transformation
    let prompt = 'Transform this portrait into a high-quality 3D CGI rendered character, ';

    // Add physical characteristics from measurements
    if (measurements) {
      // Height-based build description
      const height = Number(measurements.height) || 170;
      if (height < 160) {
        prompt += 'maintaining their petite build and shorter stature, ';
      } else if (height > 185) {
        prompt += 'maintaining their tall stature and commanding presence, ';
      } else {
        prompt += 'maintaining their natural proportions and build, ';
      }

      // Body proportions for CGI accuracy
      const chest = Number(measurements.chest) || 90;
      const waist = Number(measurements.waist) || 80;
      const ratio = chest / waist;

      if (ratio > 1.3) {
        prompt += 'with athletic physique and broad shoulders, ';
      } else if (ratio < 1.1) {
        prompt += 'with slender frame and elegant proportions, ';
      } else {
        prompt += 'with balanced proportions and healthy build, ';
      }
    }

    // Style-specific CGI enhancements
    switch (style) {
      case 'realistic':
        prompt += 'photorealistic 3D CGI rendering with perfect skin textures, ';
        prompt += 'professional studio lighting, high-resolution details, ';
        break;
      case 'cinematic':
        prompt += 'cinematic 3D CGI style with dramatic lighting and film-quality rendering, ';
        prompt += 'movie-grade visual effects, enhanced depth and atmosphere, ';
        break;
      case 'artistic':
        prompt += 'artistic 3D CGI interpretation with stylized but realistic features, ';
        prompt += 'enhanced artistic lighting and composition, ';
        break;
      default:
        prompt += 'high-quality 3D CGI rendering with professional lighting, ';
    }

    // Technical CGI specifications
    prompt += 'perfect facial geometry, subsurface scattering, ';
    prompt += 'PBR materials, realistic hair and eye rendering, ';
    prompt += '4K texture resolution, animation-ready topology, ';
    prompt += 'studio-quality 3D CGI character model';

    console.log('‚úÖ Generated basic CGI enhancement prompt:', prompt);
    return prompt;
  }

  /**
   * Process Nano Banana Edit result into enhanced avatar format
   */
  processEnhanced3DAvatar(
    response: NanoBananaEditResponse,
    prompt: string,
    style: string,
    photoCount: number,
    perspective: string = 'portrait',
    cgiPreset: string = 'animation_studio',
    strength: number = 0.8
  ): Enhanced3DAvatar | null {
    if (!response.success || !response.images || response.images.length === 0) {
      return null;
    }

    const primaryImage = response.images[0];
    const qualityScore = this.calculateCGIQualityScore(response, prompt, photoCount, strength);

    // Analyze CGI quality and features
    const cgiAnalysis = cgiPromptEnhancer.analyzeCGIQuality(primaryImage.url, cgiPreset);

    return {
      imageUrl: primaryImage.url,
      description: `CGI-enhanced 3D avatar with ${cgiPreset} quality preset`,
      metadata: {
        prompt,
        style,
        quality: photoCount > 0 ? 'cgi_photo_enhanced' : 'cgi_demo_enhanced',
        generation_time: Date.now(),
        model: 'nano_banana_edit_cgi',
        perspective,
        lighting: this.extractLightingInfo(prompt),
        enhancement_type: 'cgi_photo_enhancement',
        reference_photos_count: photoCount,
        // CGI-specific metadata
        cgi_preset: cgiPreset,
        cgi_features: cgiAnalysis.cgiFeatures,
        technical_specs: cgiAnalysis.technicalMetrics,
        strength
      },
      qualityScore: Math.max(qualityScore, cgiAnalysis.qualityScore)
    };
  }

  /**
   * Calculate quality score for CGI enhancement
   */
  private calculateCGIQualityScore(
    response: NanoBananaEditResponse,
    prompt: string,
    photoCount: number,
    strength: number
  ): number {
    let score = 85; // Base score for Nano Banana Edit

    // Major bonus for using reference photos
    if (photoCount > 0) {
      score += 10; // +10 for photo enhancement
      score += Math.min(photoCount * 1, 5); // +1 per photo, max +5
    }

    // Bonus for high strength (more CGI transformation)
    if (strength >= 0.7) {
      score += 5; // +5 for strong CGI transformation
    }

    // Bonus for successful generation
    if (response.success && response.images && response.images.length > 0) {
      score += 5;
    }

    // Bonus for CGI-specific terms in prompt
    if (prompt.includes('CGI') && prompt.includes('3D')) {
      score += 5;
    }

    return Math.min(100, score);
  }

  /**
   * Extract lighting information from prompt
   */
  private extractLightingInfo(prompt: string): string {
    const lightingTerms = {
      'studio lighting': 'studio',
      'dramatic lighting': 'dramatic',
      'natural lighting': 'natural',
      'professional lighting': 'professional',
      'cinematic': 'cinematic',
      '3D': '3d_cgi'
    };

    for (const [term, type] of Object.entries(lightingTerms)) {
      if (prompt.toLowerCase().includes(term)) {
        return type;
      }
    }

    return 'cgi_enhanced';
  }

  /**
   * Generate fallback enhanced avatar for development/demo
   */
  async generateFallbackEnhancedAvatar(
    capturedPhotos: any[],
    measurements: any,
    cgiPreset: string = 'animation_studio'
  ): Promise<Enhanced3DAvatar> {
    console.log('üé≠ Generating fallback enhanced avatar for development');
    console.log('üé¨ CGI Preset for fallback:', cgiPreset);

    // Simulate processing time
    await new Promise(resolve => setTimeout(resolve, 2000));

    const prompt = this.generateCGIEnhancementPrompt(measurements, 'realistic', 'portrait', cgiPreset);
    const photoCount = capturedPhotos?.length || 0;

    // Analyze CGI quality for fallback
    const cgiAnalysis = cgiPromptEnhancer.analyzeCGIQuality('', cgiPreset);

    return {
      imageUrl: '', // Empty - will show empty state
      description: `Fallback CGI-enhanced avatar with ${cgiPreset} quality preset`,
      metadata: {
        prompt,
        style: 'realistic',
        quality: 'demo_cgi_enhanced',
        generation_time: Date.now(),
        model: 'nano_banana_edit_cgi_fallback',
        perspective: 'portrait',
        lighting: 'cgi_enhanced',
        enhancement_type: 'cgi_photo_enhancement',
        reference_photos_count: photoCount,
        // CGI-specific metadata
        cgi_preset: cgiPreset,
        cgi_features: cgiAnalysis.cgiFeatures,
        technical_specs: cgiAnalysis.technicalMetrics,
        strength: 0.8
      },
      qualityScore: Math.max(photoCount > 0 ? 90 : 75, cgiAnalysis.qualityScore)
    };
  }

  /**
   * Validate API configuration for Nano Banana Edit
   */
  validateConfiguration(): { isValid: boolean; errors: string[] } {
    // Use centralized environment configuration validation
    const configValidation = environmentConfig.validateConfiguration();
    return {
      isValid: configValidation.isValid,
      errors: configValidation.errors
    };
  }

  /**
   * Get available CGI enhancement presets
   */
  getAvailableCGIPresets(): Array<{ id: string; name: string; description: string }> {
    return cgiPromptEnhancer.getAvailableCGIPresets();
  }
}

// Export singleton instance
export const nanoBananaEditService = new NanoBananaEditService();
export default nanoBananaEditService;