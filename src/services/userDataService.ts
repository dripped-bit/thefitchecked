/**
 * UserDataService - Comprehensive user data persistence and learning system
 * Saves: avatar image, measurements, style preferences, virtual closet, wishlist, past outfit ratings
 * Implements learning system that tracks user interactions to improve recommendations
 * Provides quick-load functionality for returning users to bypass setup pages
 */

import type { UserProfile, ClothingItem } from '../types';
import type { StyleProfile } from './outfitGenerationService';
import type { DailySuggestions, PersonalizedSuggestion, OccasionType } from './personalizedFashionService';
import authService from './authService';

export interface UserMeasurements {
  height: number; // in inches
  weight?: number; // in pounds
  chest?: number; // in inches
  waist?: number; // in inches
  hips?: number; // in inches
  inseam?: number; // in inches
  shoeSize?: number;
  dressSize?: string;
  preferredFit: 'loose' | 'regular' | 'fitted';
}

export interface AvatarData {
  imageUrl: string;
  generatedAt: string;
  sourcePhotos?: string[];
  avatarType: 'uploaded' | 'generated';
  metadata?: {
    age?: number;
    ethnicity?: string;
    bodyType?: string;
    hairColor?: string;
  };
}

export interface WishlistItem {
  id: string;
  name: string;
  imageUrl?: string;
  price?: number;
  store?: string;
  url?: string;
  category: string;
  addedAt: string;
  priority: 'low' | 'medium' | 'high';
  tags: string[];
}

export interface OutfitRating {
  suggestionId: string;
  outfitImageUrl: string;
  rating: 'love' | 'like' | 'dislike' | 'hate';
  ratedAt: string;
  context: {
    weather: string;
    occasion: string;
    mood?: string;
    actualWorn?: boolean;
  };
  feedback?: string;
}

export interface UserInteraction {
  type: 'outfit_save' | 'outfit_skip' | 'outfit_rating' | 'shopping_click' | 'style_preference' | 'closet_add' | 'closet_remove';
  data: any;
  timestamp: string;
  sessionId: string;
  context?: {
    weather?: string;
    occasion?: string;
    timeOfDay?: string;
  };
}

export interface UserPreferenceProfile {
  // Style preferences learned from interactions
  preferredStyles: Map<string, number>; // style -> confidence score
  preferredColors: Map<string, number>; // color -> confidence score
  preferredBrands: Map<string, number>; // brand -> confidence score
  preferredPriceRanges: Map<string, number>; // price range -> confidence score

  // Occasion preferences
  occasionPreferences: Map<string, number>; // occasion -> confidence score

  // Weather preferences
  weatherPreferences: Map<string, Map<string, number>>; // weather condition -> style -> confidence

  // Temporal preferences
  timeOfDayPreferences: Map<string, string[]>; // time -> preferred styles
  seasonalPreferences: Map<string, string[]>; // season -> preferred styles

  // Negative preferences (things to avoid)
  avoidedStyles: Set<string>;
  avoidedColors: Set<string>;
  avoidedBrands: Set<string>;

  // Confidence scores
  confidenceLevel: number; // 0-1, how much data we have
  lastUpdated: string;
}

export interface CompleteUserData {
  profile: UserProfile;
  avatar: AvatarData;
  measurements: UserMeasurements;
  styleProfile: StyleProfile;
  closet: ClothingItem[];
  wishlist: WishlistItem[];
  outfitRatings: OutfitRating[];
  interactions: UserInteraction[];
  preferences: UserPreferenceProfile;
  settings: {
    autoGenerateDaily: boolean;
    notificationsEnabled: boolean;
    weatherLocation?: string;
    preferredCurrency: string;
    privacyLevel: 'public' | 'friends' | 'private';
    qualityPreference?: 'battery_saver' | 'balanced' | 'high_quality'; // Image output quality preference
  };
  metadata: {
    accountCreated: string;
    lastLogin: string;
    setupCompleted: boolean;
    dataVersion: string;
    totalInteractions: number;
  };
}

class UserDataService {
  private readonly STORAGE_PREFIX = 'fitChecked_';
  private readonly DATA_VERSION = '1.0';
  private currentSessionId: string;
  private userData: CompleteUserData | null = null;

  constructor() {
    this.currentSessionId = this.generateSessionId();
    this.initializeIfNeeded();
  }

  /**
   * Get user ID - requires authenticated user (no anonymous access)
   */
  async getUserId(): Promise<string> {
    const user = await authService.getCurrentUser();
    if (!user?.email) {
      throw new Error('User must be authenticated to access this feature');
    }
    return user.email;
  }

  /**
   * Initialize user data structure if it doesn't exist
   */
  private initializeIfNeeded(): void {
    const existing = this.loadUserData();
    if (!existing) {
      this.userData = this.createEmptyUserData();
      this.saveUserData();
    } else {
      this.userData = existing;
    }
  }

  /**
   * Create empty user data structure
   */
  private createEmptyUserData(): CompleteUserData {
    return {
      profile: {
        id: this.generateUserId(),
        name: '',
        age: 0,
        gender: '',
        style_preferences: [],
        created_at: new Date().toISOString()
      },
      avatar: {
        imageUrl: '',
        generatedAt: '',
        avatarType: 'uploaded'
      },
      measurements: {
        height: 0,
        preferredFit: 'regular'
      },
      styleProfile: {
        fashionPersonality: {
          archetypes: [],
          colorPalette: [],
          preferredStyles: []
        }
      },
      closet: [],
      wishlist: [],
      outfitRatings: [],
      interactions: [],
      preferences: {
        preferredStyles: new Map(),
        preferredColors: new Map(),
        preferredBrands: new Map(),
        preferredPriceRanges: new Map(),
        occasionPreferences: new Map(),
        weatherPreferences: new Map(),
        timeOfDayPreferences: new Map(),
        seasonalPreferences: new Map(),
        avoidedStyles: new Set(),
        avoidedColors: new Set(),
        avoidedBrands: new Set(),
        confidenceLevel: 0,
        lastUpdated: new Date().toISOString()
      },
      settings: {
        autoGenerateDaily: true,
        notificationsEnabled: true,
        preferredCurrency: 'USD',
        privacyLevel: 'private'
      },
      metadata: {
        accountCreated: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
        setupCompleted: false,
        dataVersion: this.DATA_VERSION,
        totalInteractions: 0
      }
    };
  }

  /**
   * Check if user has completed initial setup
   */
  isSetupCompleted(): boolean {
    return this.userData?.metadata.setupCompleted || false;
  }

  /**
   * Check if user can skip to personalized suggestions (page 6)
   */
  canSkipToSuggestions(): boolean {
    if (!this.userData) return false;

    const hasAvatar = !!this.userData.avatar.imageUrl;
    const hasBasicProfile = !!this.userData.profile.name && this.userData.profile.age > 0;
    const hasStylePreferences = this.userData.styleProfile.fashionPersonality?.archetypes?.length > 0;
    const hasAtLeastSomeData = hasAvatar || hasBasicProfile || hasStylePreferences;

    return this.userData.metadata.setupCompleted || hasAtLeastSomeData;
  }

  /**
   * Save complete user profile data
   */
  saveUserProfile(profile: UserProfile): void {
    if (this.userData) {
      this.userData.profile = { ...profile };
      this.userData.metadata.lastLogin = new Date().toISOString();
      this.saveUserData();
      console.log('üíæ [USER-DATA] Profile saved');
    }
  }

  /**
   * Save avatar data
   */
  saveAvatarData(avatar: AvatarData): void {
    if (this.userData) {
      this.userData.avatar = { ...avatar };
      this.saveUserData();
      console.log('üíæ [USER-DATA] Avatar saved');
    }
  }

  /**
   * Save user measurements
   */
  saveMeasurements(measurements: UserMeasurements): void {
    if (this.userData) {
      this.userData.measurements = { ...measurements };
      this.saveUserData();
      console.log('üíæ [USER-DATA] Measurements saved');
    }
  }

  /**
   * Save style profile
   */
  saveStyleProfile(styleProfile: StyleProfile): void {
    if (this.userData) {
      this.userData.styleProfile = { ...styleProfile };
      this.saveUserData();
      console.log('üíæ [USER-DATA] Style profile saved');
    }
  }

  /**
   * Save closet items
   */
  saveClosetItems(items: ClothingItem[]): void {
    if (this.userData) {
      this.userData.closet = [...items];
      this.saveUserData();
      console.log(`üíæ [USER-DATA] Closet saved (${items.length} items)`);
    }
  }

  /**
   * Add item to closet
   */
  addToCloset(item: ClothingItem): void {
    if (this.userData) {
      this.userData.closet.push(item);
      this.trackInteraction('closet_add', { item });
      this.saveUserData();
      console.log('üíæ [USER-DATA] Item added to closet');
    }
  }

  /**
   * Remove item from closet
   */
  removeFromCloset(itemId: string): void {
    if (this.userData) {
      const index = this.userData.closet.findIndex(item => item.id === itemId);
      if (index > -1) {
        const removedItem = this.userData.closet.splice(index, 1)[0];
        this.trackInteraction('closet_remove', { item: removedItem });
        this.saveUserData();
        console.log('üíæ [USER-DATA] Item removed from closet');
      }
    }
  }

  /**
   * Save wishlist items
   */
  saveWishlistItems(items: WishlistItem[]): void {
    if (this.userData) {
      this.userData.wishlist = [...items];
      this.saveUserData();
      console.log(`üíæ [USER-DATA] Wishlist saved (${items.length} items)`);
    }
  }

  /**
   * Add item to wishlist
   */
  addToWishlist(item: WishlistItem): void {
    if (this.userData) {
      this.userData.wishlist.push(item);
      this.saveUserData();
      console.log('üíæ [USER-DATA] Item added to wishlist');
    }
  }

  /**
   * Rate an outfit suggestion (learning system)
   */
  rateOutfit(rating: OutfitRating): void {
    if (this.userData) {
      this.userData.outfitRatings.push(rating);
      this.trackInteraction('outfit_rating', rating);
      this.updatePreferencesFromRating(rating);
      this.saveUserData();
      console.log(`üß† [LEARNING] Outfit rated: ${rating.rating}`);
    }
  }

  /**
   * Track user interaction for learning system
   */
  trackInteraction(type: UserInteraction['type'], data: any, context?: UserInteraction['context']): void {
    if (this.userData) {
      const interaction: UserInteraction = {
        type,
        data,
        timestamp: new Date().toISOString(),
        sessionId: this.currentSessionId,
        context
      };

      this.userData.interactions.push(interaction);
      this.userData.metadata.totalInteractions++;

      // Keep only last 1000 interactions to prevent storage bloat
      if (this.userData.interactions.length > 1000) {
        this.userData.interactions = this.userData.interactions.slice(-1000);
      }

      // Update preferences based on interaction
      this.updatePreferencesFromInteraction(interaction);

      this.saveUserData();
      console.log(`üìä [LEARNING] Tracked ${type} interaction`);
    }
  }

  /**
   * Update preference profile from outfit rating (learning algorithm)
   */
  private updatePreferencesFromRating(rating: OutfitRating): void {
    if (!this.userData) return;

    const preferences = this.userData.preferences;
    const weight = this.getRatingWeight(rating.rating);

    // Extract style information from the rating context
    // This would ideally analyze the outfit image to extract style features
    // For now, we'll use context data

    if (rating.context.occasion) {
      this.updateMapScore(preferences.occasionPreferences, rating.context.occasion, weight);
    }

    if (rating.context.weather) {
      // Update weather-based preferences
      if (!preferences.weatherPreferences.has(rating.context.weather)) {
        preferences.weatherPreferences.set(rating.context.weather, new Map());
      }
      // This would be enhanced with actual style extraction from the outfit
    }

    // Update confidence level
    preferences.confidenceLevel = Math.min(preferences.confidenceLevel + 0.01, 1.0);
    preferences.lastUpdated = new Date().toISOString();
  }

  /**
   * Update preference profile from user interaction
   */
  private updatePreferencesFromInteraction(interaction: UserInteraction): void {
    if (!this.userData) return;

    const preferences = this.userData.preferences;

    switch (interaction.type) {
      case 'outfit_save':
        // Positive signal - increase preference for saved outfit characteristics
        this.reinforcePositivePreferences(interaction.data, 0.3);
        break;

      case 'outfit_skip':
        // Negative signal - decrease preference for skipped outfit characteristics
        this.reinforceNegativePreferences(interaction.data, -0.1);
        break;

      case 'shopping_click':
        // Strong positive signal - user is interested enough to shop
        this.reinforcePositivePreferences(interaction.data, 0.5);
        break;

      case 'style_preference':
        // Direct preference input - high weight
        this.reinforcePositivePreferences(interaction.data, 0.7);
        break;
    }

    preferences.lastUpdated = new Date().toISOString();
  }

  /**
   * Reinforce positive preferences based on user actions
   */
  private reinforcePositivePreferences(data: any, weight: number): void {
    if (!this.userData) return;

    const preferences = this.userData.preferences;

    // Extract and reinforce style preferences from the data
    if (data.styles) {
      data.styles.forEach((style: string) => {
        this.updateMapScore(preferences.preferredStyles, style, weight);
      });
    }

    if (data.colors) {
      data.colors.forEach((color: string) => {
        this.updateMapScore(preferences.preferredColors, color, weight);
      });
    }

    if (data.occasion) {
      this.updateMapScore(preferences.occasionPreferences, data.occasion, weight);
    }

    // Remove from avoided sets if positively reinforced
    if (data.styles) {
      data.styles.forEach((style: string) => preferences.avoidedStyles.delete(style));
    }
    if (data.colors) {
      data.colors.forEach((color: string) => preferences.avoidedColors.delete(color));
    }
  }

  /**
   * Reinforce negative preferences based on user actions
   */
  private reinforceNegativePreferences(data: any, weight: number): void {
    if (!this.userData) return;

    const preferences = this.userData.preferences;

    // Extract and negatively reinforce preferences
    if (data.styles) {
      data.styles.forEach((style: string) => {
        this.updateMapScore(preferences.preferredStyles, style, weight);
        // Add to avoided if score gets very low
        const currentScore = preferences.preferredStyles.get(style) || 0;
        if (currentScore < -0.5) {
          preferences.avoidedStyles.add(style);
        }
      });
    }

    if (data.colors) {
      data.colors.forEach((color: string) => {
        this.updateMapScore(preferences.preferredColors, color, weight);
        const currentScore = preferences.preferredColors.get(color) || 0;
        if (currentScore < -0.5) {
          preferences.avoidedColors.add(color);
        }
      });
    }
  }

  /**
   * Update score in a Map with decay and bounds
   */
  private updateMapScore(map: Map<string, number>, key: string, delta: number): void {
    const currentScore = map.get(key) || 0;
    const newScore = Math.max(-1, Math.min(1, currentScore + delta));
    map.set(key, newScore);
  }

  /**
   * Get rating weight for learning algorithm
   */
  private getRatingWeight(rating: OutfitRating['rating']): number {
    switch (rating) {
      case 'love': return 1.0;
      case 'like': return 0.5;
      case 'dislike': return -0.5;
      case 'hate': return -1.0;
      default: return 0;
    }
  }

  /**
   * Get personalized recommendations based on learned preferences
   */
  getPersonalizedRecommendations(): {
    preferredStyles: string[];
    preferredColors: string[];
    avoidedItems: string[];
    confidenceLevel: number;
  } {
    if (!this.userData) {
      return {
        preferredStyles: [],
        preferredColors: [],
        avoidedItems: [],
        confidenceLevel: 0
      };
    }

    const preferences = this.userData.preferences;

    // Get top preferred styles (score > 0.3)
    const preferredStyles = Array.from(preferences.preferredStyles.entries())
      .filter(([_, score]) => score > 0.3)
      .sort(([_, a], [__, b]) => b - a)
      .map(([style, _]) => style)
      .slice(0, 5);

    // Get top preferred colors (score > 0.3)
    const preferredColors = Array.from(preferences.preferredColors.entries())
      .filter(([_, score]) => score > 0.3)
      .sort(([_, a], [__, b]) => b - a)
      .map(([color, _]) => color)
      .slice(0, 5);

    // Get avoided items
    const avoidedItems = [
      ...Array.from(preferences.avoidedStyles),
      ...Array.from(preferences.avoidedColors)
    ];

    return {
      preferredStyles,
      preferredColors,
      avoidedItems,
      confidenceLevel: preferences.confidenceLevel
    };
  }

  /**
   * Mark setup as completed
   */
  markSetupCompleted(): void {
    if (this.userData) {
      this.userData.metadata.setupCompleted = true;
      this.userData.metadata.lastLogin = new Date().toISOString();
      this.saveUserData();
      console.log('‚úÖ [USER-DATA] Setup marked as completed');
    }
  }

  /**
   * Load all user data for quick-load functionality
   */
  loadUserData(): CompleteUserData | null {
    try {
      const stored = localStorage.getItem(`${this.STORAGE_PREFIX}userData`);
      if (stored) {
        const parsed = JSON.parse(stored);
        // Restore Map and Set objects
        return this.restoreUserData(parsed);
      }
    } catch (error) {
      console.error('Failed to load user data:', error);
    }
    return null;
  }

  /**
   * Save all user data
   */
  private saveUserData(): void {
    if (this.userData) {
      try {
        // Convert Map and Set objects for storage
        const serializable = this.serializeUserData(this.userData);
        localStorage.setItem(`${this.STORAGE_PREFIX}userData`, JSON.stringify(serializable));
        console.log('üíæ [USER-DATA] All data saved to localStorage');
      } catch (error) {
        console.error('Failed to save user data:', error);
      }
    }
  }

  /**
   * Convert Maps and Sets to serializable format
   */
  private serializeUserData(data: CompleteUserData): any {
    return {
      ...data,
      preferences: {
        ...data.preferences,
        preferredStyles: Array.from(data.preferences.preferredStyles.entries()),
        preferredColors: Array.from(data.preferences.preferredColors.entries()),
        preferredBrands: Array.from(data.preferences.preferredBrands.entries()),
        preferredPriceRanges: Array.from(data.preferences.preferredPriceRanges.entries()),
        occasionPreferences: Array.from(data.preferences.occasionPreferences.entries()),
        weatherPreferences: Array.from(data.preferences.weatherPreferences.entries()).map(([key, value]) => [
          key,
          Array.from(value.entries())
        ]),
        timeOfDayPreferences: Array.from(data.preferences.timeOfDayPreferences.entries()),
        seasonalPreferences: Array.from(data.preferences.seasonalPreferences.entries()),
        avoidedStyles: Array.from(data.preferences.avoidedStyles),
        avoidedColors: Array.from(data.preferences.avoidedColors),
        avoidedBrands: Array.from(data.preferences.avoidedBrands)
      }
    };
  }

  /**
   * Restore Maps and Sets from serialized format
   */
  private restoreUserData(data: any): CompleteUserData {
    return {
      ...data,
      preferences: {
        ...data.preferences,
        preferredStyles: new Map(data.preferences.preferredStyles || []),
        preferredColors: new Map(data.preferences.preferredColors || []),
        preferredBrands: new Map(data.preferences.preferredBrands || []),
        preferredPriceRanges: new Map(data.preferences.preferredPriceRanges || []),
        occasionPreferences: new Map(data.preferences.occasionPreferences || []),
        weatherPreferences: new Map((data.preferences.weatherPreferences || []).map(([key, value]: [string, any[]]) => [
          key,
          new Map(value)
        ])),
        timeOfDayPreferences: new Map(data.preferences.timeOfDayPreferences || []),
        seasonalPreferences: new Map(data.preferences.seasonalPreferences || []),
        avoidedStyles: new Set(data.preferences.avoidedStyles || []),
        avoidedColors: new Set(data.preferences.avoidedColors || []),
        avoidedBrands: new Set(data.preferences.avoidedBrands || [])
      }
    };
  }

  /**
   * Get all user data
   */
  getAllUserData(): CompleteUserData | null {
    return this.userData;
  }

  /**
   * Export user data for backup/transfer
   */
  exportUserData(): string {
    if (this.userData) {
      return JSON.stringify(this.serializeUserData(this.userData), null, 2);
    }
    return '';
  }

  /**
   * Import user data from backup
   */
  importUserData(jsonData: string): boolean {
    try {
      const parsed = JSON.parse(jsonData);
      this.userData = this.restoreUserData(parsed);
      this.saveUserData();
      console.log('‚úÖ [USER-DATA] Data imported successfully');
      return true;
    } catch (error) {
      console.error('Failed to import user data:', error);
      return false;
    }
  }

  /**
   * Clear all user data (reset)
   */
  clearAllData(): void {
    localStorage.removeItem(`${this.STORAGE_PREFIX}userData`);
    this.userData = this.createEmptyUserData();
    this.saveUserData();
    console.log('üóëÔ∏è [USER-DATA] All data cleared');
  }

  /**
   * Generate unique user ID
   */
  private generateUserId(): string {
    return `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Generate unique session ID
   */
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get user statistics for analytics
   */
  getUserStats(): {
    totalInteractions: number;
    setupCompleted: boolean;
    accountAge: number;
    confidenceLevel: number;
    closetSize: number;
    wishlistSize: number;
    totalRatings: number;
  } {
    if (!this.userData) {
      return {
        totalInteractions: 0,
        setupCompleted: false,
        accountAge: 0,
        confidenceLevel: 0,
        closetSize: 0,
        wishlistSize: 0,
        totalRatings: 0
      };
    }

    const accountAge = Date.now() - new Date(this.userData.metadata.accountCreated).getTime();

    return {
      totalInteractions: this.userData.metadata.totalInteractions,
      setupCompleted: this.userData.metadata.setupCompleted,
      accountAge: Math.floor(accountAge / (1000 * 60 * 60 * 24)), // days
      confidenceLevel: this.userData.preferences.confidenceLevel,
      closetSize: this.userData.closet.length,
      wishlistSize: this.userData.wishlist.length,
      totalRatings: this.userData.outfitRatings.length
    };
  }
}

// Singleton instance
export const userDataService = new UserDataService();
export default userDataService;