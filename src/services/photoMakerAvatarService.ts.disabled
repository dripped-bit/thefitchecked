/**
 * PhotoMaker Avatar Service
 * Handles personalized 3D realistic avatar generation using user photos and measurements
 * Uses PhotoMaker model via fal.ai API for identity-preserving avatar creation
 */

import { environmentConfig } from './environmentConfig';
import { cgiPromptEnhancer } from './cgiPromptEnhancer';

export interface PhotoMakerGenerationRequest {
  image_archive_url: string;
  prompt: string;
  base_pipeline?: 'photomaker' | 'photomaker-style';
  initial_image_url?: string;
  initial_image_strength?: number;
  style?: 'Photographic' | 'Cinematic' | 'Disney Character' | 'Digital Art' | 'Fantasy art' | 'Neonpunk' | 'Enhance' | 'Comic book' | 'Lowpoly' | 'Line art' | '(No style)';
  negative_prompt?: string;
  num_inference_steps?: number;
  style_strength?: number;
  num_images?: number;
  guidance_scale?: number;
  seed?: number;
}

export interface PhotoMakerGenerationResponse {
  success: boolean;
  images?: Array<{
    url: string;
    width: number;
    height: number;
    file_size: number;
    file_name: string;
    content_type: string;
  }>;
  seed?: number;
  error?: string;
}

export interface PersonalizedAvatar3DData {
  imageUrl: string;
  description?: string;
  metadata: {
    prompt: string;
    style: string;
    quality: string;
    generation_time: number;
    model: string;
    perspective: string;
    lighting: string;
    personalization: 'photos_used' | 'fallback';
    reference_photos_count: number;
    // CGI-specific metadata
    cgi_preset?: string;
    cgi_features?: string[];
    technical_specs?: Record<string, any>;
  };
  qualityScore: number;
}

export class PhotoMakerAvatarService {
  private readonly config = environmentConfig.getPhotoMakerConfig();

  /**
   * Generate personalized 3D realistic avatar using PhotoMaker
   */
  async generatePersonalizedAvatar(
    capturedPhotos: any[],
    measurements: any,
    request: Partial<PhotoMakerGenerationRequest> = {}
  ): Promise<PhotoMakerGenerationResponse> {
    try {
      console.log('üé® Starting PhotoMaker personalized avatar generation');
      console.log('üì∏ Reference photos:', capturedPhotos?.length || 0);
      console.log('üìè Measurements:', measurements);

      // Step 1: Create image archive URL from captured photos
      const imageArchiveUrl = await this.createImageArchiveUrl(capturedPhotos);

      if (!imageArchiveUrl) {
        throw new Error('No valid photos provided for PhotoMaker personalization. Please ensure photos are captured.');
      }

      // Step 2: Generate CGI-enhanced personalized prompt from measurements
      const cgiConfig = environmentConfig.getCGIEnhancementConfig();
      const avatarConfig = environmentConfig.getAvatarGenerationConfig();
      const prompt = this.generatePersonalizedPrompt(
        measurements,
        request.style || 'Photographic',
        avatarConfig.perspective,
        cgiConfig.qualityPreset
      );

      // Step 3: Prepare PhotoMaker request according to API specification
      const photoMakerRequest: PhotoMakerGenerationRequest = {
        image_archive_url: imageArchiveUrl,
        prompt,
        base_pipeline: 'photomaker',
        style: request.style || this.config.defaultStyle,
        num_images: request.num_images || this.config.defaultNumImages,
        style_strength: request.style_strength || this.config.defaultStyleStrength,
        guidance_scale: request.guidance_scale || this.config.defaultGuidanceScale,
        num_inference_steps: request.num_inference_steps || this.config.defaultInferenceSteps,
        negative_prompt: 'nsfw, lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry'
      };

      console.log('üöÄ Sending request to PhotoMaker API');
      const startTime = Date.now();

      // Step 4: Call PhotoMaker API via fal.ai
      const { fal } = await import('@fal-ai/client');

      const result = await fal.subscribe('fal-ai/photomaker', {
        input: photoMakerRequest,
        logs: true,
        onQueueUpdate: (update) => {
          if (update.status === 'IN_PROGRESS') {
            update.logs?.map((log) => log.message).forEach(console.log);
          }
        },
      });

      const generationTime = Date.now() - startTime;
      console.log(`‚úÖ PhotoMaker personalized avatar generation completed in ${generationTime}ms`);

      if (!result.data || !result.data.images || result.data.images.length === 0) {
        throw new Error('No images generated by PhotoMaker API');
      }

      return {
        success: true,
        images: result.data.images,
        seed: result.data.seed
      };

    } catch (error) {
      console.error('‚ùå PhotoMaker generation failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
  }

  /**
   * Create image archive URL from captured photos for PhotoMaker
   * For now, we'll use a demo URL - in production, this would upload photos to a cloud storage service
   */
  private async createImageArchiveUrl(capturedPhotos: any[]): Promise<string | null> {
    if (!capturedPhotos || capturedPhotos.length === 0) {
      console.log('üì∏ No photos provided for personalization');
      return null;
    }

    try {
      console.log('üì¶ Creating photo archive URL for PhotoMaker...');

      // Filter valid photos
      const validPhotos = capturedPhotos.filter(photo => {
        return photo && (photo.blob || photo.file || photo.dataUrl);
      });

      if (validPhotos.length === 0) {
        console.warn('‚ö†Ô∏è No valid photo data found for archive creation');
        return null;
      }

      console.log(`üì∏ Found ${validPhotos.length} valid photos for personalization`);

      // For development/demo purposes, we'll use the demo URL from the API documentation
      // In production, this would:
      // 1. Create a ZIP file with the captured photos
      // 2. Upload it to a cloud storage service (AWS S3, Google Cloud Storage, etc.)
      // 3. Return the public URL to that ZIP file

      // Demo URL from PhotoMaker API documentation
      const demoImageArchiveUrl = 'https://storage.googleapis.com/falserverless/model_tests/photomaker/elon.zip';

      console.log('üîß Using demo image archive URL for development:', demoImageArchiveUrl);
      console.log('‚ö†Ô∏è In production, this would be replaced with user photos uploaded to cloud storage');

      return demoImageArchiveUrl;

    } catch (error) {
      console.error('‚ùå Failed to create image archive URL:', error);
      return null;
    }
  }

  /**
   * Generate CGI-enhanced personalized prompt combining measurements and style preferences
   */
  generatePersonalizedPrompt(
    measurements: any,
    style: string = 'Photographic',
    perspective: string = 'portrait',
    cgiPreset: string = 'animation_studio'
  ): string {
    console.log('üî§ Generating CGI-enhanced personalized PhotoMaker prompt');
    console.log('üé¨ CGI Preset:', cgiPreset);

    // Use CGI prompt enhancer to generate professional 3D CGI prompt
    const cgiPrompt = cgiPromptEnhancer.generateCGIPromptForAvatar(
      measurements,
      style,
      perspective,
      cgiPreset
    );

    console.log('‚úÖ Generated CGI-enhanced personalized prompt:', cgiPrompt);
    return cgiPrompt;
  }

  /**
   * Generate basic personalized prompt (fallback without CGI)
   */
  generateBasicPersonalizedPrompt(
    measurements: any,
    style: string = 'Photographic',
    perspective: string = 'portrait'
  ): string {
    console.log('üî§ Generating basic personalized PhotoMaker prompt');

    // Base prompt for PhotoMaker personalized generation
    let prompt = 'High-quality professional portrait of the person in the reference photos, ';

    // Add physical characteristics from measurements to enhance body representation
    if (measurements) {
      // Height-based build description
      const height = Number(measurements.height) || 170;
      if (height < 160) {
        prompt += 'maintaining their petite build and shorter stature, ';
      } else if (height > 185) {
        prompt += 'maintaining their tall stature and commanding presence, ';
      } else {
        prompt += 'maintaining their natural proportions and build, ';
      }

      // Body proportions for enhanced accuracy
      const chest = Number(measurements.chest) || 90;
      const waist = Number(measurements.waist) || 80;
      const ratio = chest / waist;

      if (ratio > 1.3) {
        prompt += 'with athletic physique and broad shoulders, ';
      } else if (ratio < 1.1) {
        prompt += 'with slender frame and elegant proportions, ';
      } else {
        prompt += 'with balanced proportions and healthy build, ';
      }

      // Gender-specific enhancements if provided
      if (measurements.gender) {
        const gender = measurements.gender.toLowerCase();
        if (gender === 'male') {
          prompt += 'preserving masculine facial features and bone structure, ';
        } else if (gender === 'female') {
          prompt += 'preserving feminine facial features and graceful bone structure, ';
        }
      }
    }

    // Style-specific enhancements
    switch (style) {
      case 'Photographic':
        prompt += 'photorealistic style with natural lighting, sharp details, professional photography quality, ';
        prompt += 'studio lighting setup, high-resolution clarity, ';
        break;
      case 'Cinematic':
        prompt += 'cinematic portrait style with dramatic lighting, film-like quality, ';
        prompt += 'movie poster aesthetics, enhanced depth and atmosphere, ';
        break;
      case 'Disney Character':
        prompt += 'Disney animation character style while maintaining recognizable features, ';
        prompt += 'stylized but identifiable, animated movie quality, ';
        break;
      default:
        prompt += 'high-quality professional portrait style, ';
    }

    // Perspective and composition
    switch (perspective.toLowerCase()) {
      case 'portrait':
        prompt += 'head and shoulders portrait composition, professional headshot framing, ';
        break;
      case 'bust':
        prompt += 'bust portrait with upper body visible, three-quarter view composition, ';
        break;
      case 'full':
        prompt += 'full body portrait showing complete figure from head to feet, standing pose with arms slightly away from body for optimal pose detection, suitable for virtual try-on applications with clear body landmarks, ';
        break;
      default:
        prompt += 'portrait composition with professional framing, ';
    }

    // Technical quality specifications for PhotoMaker
    prompt += 'maintaining facial identity and likeness from reference photos, ';
    prompt += 'high detail preservation, realistic skin textures, natural eye expressions, ';
    prompt += 'professional portrait quality, 4K resolution, masterpiece quality';

    console.log('‚úÖ Generated basic personalized PhotoMaker prompt:', prompt);
    return prompt;
  }

  /**
   * Process PhotoMaker result into our avatar format
   */
  processPersonalizedAvatarResult(
    response: PhotoMakerGenerationResponse,
    prompt: string,
    style: string,
    photoCount: number,
    perspective: string = 'portrait',
    cgiPreset: string = 'animation_studio'
  ): PersonalizedAvatar3DData | null {
    if (!response.success || !response.images || response.images.length === 0) {
      return null;
    }

    const primaryImage = response.images[0];
    const qualityScore = this.calculatePersonalizationQualityScore(response, prompt, photoCount);

    // Analyze CGI quality and features
    const cgiAnalysis = cgiPromptEnhancer.analyzeCGIQuality(primaryImage.url, cgiPreset);

    return {
      imageUrl: primaryImage.url,
      description: `Personalized CGI avatar generated with ${cgiPreset} quality preset`,
      metadata: {
        prompt,
        style,
        quality: photoCount > 0 ? 'personalized_cgi' : 'generic_cgi',
        generation_time: Date.now(),
        model: 'photomaker_cgi',
        perspective,
        lighting: this.extractLightingInfo(prompt),
        personalization: photoCount > 0 ? 'photos_used' : 'fallback',
        reference_photos_count: photoCount,
        // CGI-specific metadata
        cgi_preset: cgiPreset,
        cgi_features: cgiAnalysis.cgiFeatures,
        technical_specs: cgiAnalysis.technicalMetrics
      },
      qualityScore: Math.max(qualityScore, cgiAnalysis.qualityScore)
    };
  }

  /**
   * Calculate quality score for personalized generation
   */
  private calculatePersonalizationQualityScore(
    response: PhotoMakerGenerationResponse,
    prompt: string,
    photoCount: number
  ): number {
    let score = 80; // Base score for PhotoMaker

    // Major bonus for using reference photos
    if (photoCount > 0) {
      score += 15; // +15 for personalization
      score += Math.min(photoCount * 2, 5); // +2 per photo, max +5
    }

    // Bonus for successful generation
    if (response.success && response.images && response.images.length > 0) {
      score += 5;
    }

    // Bonus for detailed prompt
    if (prompt.includes('maintaining') && prompt.includes('reference photos')) {
      score += 5;
    }

    return Math.min(100, score);
  }

  /**
   * Extract lighting information from prompt
   */
  private extractLightingInfo(prompt: string): string {
    const lightingTerms = {
      'studio lighting': 'studio',
      'dramatic lighting': 'dramatic',
      'natural lighting': 'natural',
      'professional lighting': 'professional',
      'cinematic': 'cinematic'
    };

    for (const [term, type] of Object.entries(lightingTerms)) {
      if (prompt.toLowerCase().includes(term)) {
        return type;
      }
    }

    return 'standard';
  }

  /**
   * Generate fallback personalized avatar for development/demo
   */
  async generateFallbackPersonalizedAvatar(
    capturedPhotos: any[],
    measurements: any,
    cgiPreset: string = 'animation_studio'
  ): Promise<PersonalizedAvatar3DData> {
    console.log('üé≠ Generating fallback personalized avatar for development');
    console.log('üé¨ CGI Preset for fallback:', cgiPreset);

    // Simulate processing time
    await new Promise(resolve => setTimeout(resolve, 1500));

    const prompt = this.generatePersonalizedPrompt(measurements, 'Photographic', 'portrait', cgiPreset);
    const photoCount = capturedPhotos?.length || 0;

    // Analyze CGI quality for fallback
    const cgiAnalysis = cgiPromptEnhancer.analyzeCGIQuality('', cgiPreset);

    return {
      imageUrl: '', // Empty - will show empty state
      description: `Fallback CGI avatar with ${cgiPreset} quality preset`,
      metadata: {
        prompt,
        style: 'Photographic',
        quality: 'demo_cgi',
        generation_time: Date.now(),
        model: 'photomaker_cgi_fallback',
        perspective: 'portrait',
        lighting: 'studio',
        personalization: photoCount > 0 ? 'photos_used' : 'fallback',
        reference_photos_count: photoCount,
        // CGI-specific metadata
        cgi_preset: cgiPreset,
        cgi_features: cgiAnalysis.cgiFeatures,
        technical_specs: cgiAnalysis.technicalMetrics
      },
      qualityScore: Math.max(photoCount > 0 ? 85 : 70, cgiAnalysis.qualityScore)
    };
  }

  /**
   * Validate API configuration for PhotoMaker
   */
  validateConfiguration(): { isValid: boolean; errors: string[] } {
    // Use centralized environment configuration validation
    const configValidation = environmentConfig.validateConfiguration();
    return {
      isValid: configValidation.isValid,
      errors: configValidation.errors
    };
  }

  /**
   * Get available PhotoMaker styles
   */
  getAvailablePhotoMakerStyles(): Array<{ id: string; name: string; description: string }> {
    return [
      {
        id: 'Photographic',
        name: 'Photographic',
        description: 'Realistic photographic style with natural lighting and sharp details'
      },
      {
        id: 'Cinematic',
        name: 'Cinematic',
        description: 'Dramatic cinematic portrait with film-like quality and atmosphere'
      },
      {
        id: 'Disney Character',
        name: 'Disney Character',
        description: 'Stylized Disney animation character while maintaining recognizable features'
      }
    ];
  }

  /**
   * Get available CGI quality presets
   */
  getAvailableCGIPresets(): Array<{ id: string; name: string; description: string }> {
    return cgiPromptEnhancer.getAvailableCGIPresets();
  }
}

// Export singleton instance
export const photoMakerAvatarService = new PhotoMakerAvatarService();
export default photoMakerAvatarService;